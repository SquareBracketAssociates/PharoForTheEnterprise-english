!An Introduction To Sound

In this chapter we will present an uncommon facet of Pharo: sound synthesis. Pharo offers a nice library to create and play various sounds. As soon as we need to put some sound in an application one think either to mp3 or sampled sounds. In Pharo we get several tools and libraries to create from scratch synthetized sounds as well as to play samples. We will show how we can do that with a couple of lines of code. This version is an english translation of an original french version. The author thank Kilon for his first traduction of this chapter.


!! Getting Started

!!! Getting Pharo

First we need to get and install the latest version 30 Pharo at: http://www.pharo.org/. The easiest remaining to run the script download the following in a shell.

[[[
curl get.pharo.org/30 vmLatest + | bash
]]]

or curl if not available:

[[[
wget-O-get.pharo.org/30 vmLatest + | bash
]]]

Other scripts are available for download at http://get.pharo.org. The GUI starts with ==/.pharo-ui pharo.image==

!!! Loading Sound

Once Pharo installed, you must download the package PharoSound using: 
- either the ConfigurationBrowser  (as shown in Figure *configurationBrowser*) which is found in the Tools menu. Enter ==Sound== in the text box to select the package, then press the 'Install Stable Version' button.

+Configuration browser: a package manager>file://figures/configurationBrowser.pdf|width=50|label=configurationBrowser+

- either Gofer the package manager:
[[[
Gofer new
	smalltalkhubUser 'PharoExtras' project 'Sound';
	package: 'ConfigurationOfPharoSound';
	load.
(#ConfigurationOfPharoSound asClass project version: #stable) load
]]]


!!! Setup verification

We now will verify that our environment can play a sound properly. To do this simply open a workspace (from the Tools menu) and evaluate the following line of code by selecting the expression and then using the item 'Do it' menu. We will explain later what it is. Note that in a workspace to run a line it is enough to move the mouse cursor and pressing alt-d (this is equivalent to select the line and use the menu). To select a block of instructions quickly position the mouse at the beginning or at the end of the block and click, this has the effect of selecting all.

[[[
FMSound organ1 play.
]]]

If you have sound you can skip the next paragraph, if not here are some ways to get sound working.



+Settings>file://figures/SoundSetting.pdf|width=50|label=setting+

- Enable sound in Pharo. Check that the sound setting is enabled in your Pharo. To set it, open the Settings Browser from the Tools menu. Then type ==sound==  in the bar and click the radio buttons to get close to the image shown in Figure *setting*.

- The volume of your system is too low or muted
- Pulseaudio is enabled (on virtually all current distributions)

By default the Linux archive does not carry a pulseaudio plugin, only using Alsa plugin is possible. We will disable the sound server temporarily. It should not be restarted automatically when we stop.


# Create ==/homefile/[user]/.pulse/client.conf== if there is no
# Add parameter ==autospawn = no==
# Delete the current process with the command ==pulseaudio -k== with your user account. To restart when you want, run the command ==pulseaudio -D==.


- Restart internal sound player process. It may also happen that the noise process no longer works. You can use the following commands to reset

[[[
SoundPlayer stopPlayerProcess.
SoundPlayer Startup
]]]

A little tip before we go any further on the sound rendering. Default reverb is added to the sound played. Under certain conditions can lead to a certain softness in rendering but in our case this discovery can also distort what we hear.

To disable rendering with reverb run the command

[[[
SoundPlayer stopReverb
]]]

Or restart if you prefer with

[[[
SoundPlayer startReverb
]]]



!!FM synthesis basis by example

Now that we have verified that the sound system is functional, we will discover how it is generated. Consider the method that defines the instrument ==organ1==:

[[[
FMSound class>>organ1
	"FMSound organ1 play"
	"(FMSound majorScaleOn: FMSound organ1) play"

	| sound |
	sound := self new.
	sound addEnvelope: (VolumeEnvelope 
                              points: { 0@0 . 60@1.0 . 110@0.8 . 200@1.0 . 250@0.0} 
                              loopStart: 2 loopEnd: 4).
	sound setPitch: 440.0 duration: 1.0 loudness: 0.5.
	^ snd
]]]

Let's look at this method:

First, it creates a new instance of the class ==FMSound== using the message ==new== as follows:

[[[
	sound: = self new.
]]]


It then defines a set of points to create a volume envelope. For each point in the first term expresses a given millisecond, a second volume expressed from 0 to 1 (1 being 100% of the volume).

[[[
sound addEnvelope: (VolumeEnvelope
                      points: { 0@0 . 60@1.0 . 110@0.8 . 200@1.0 . 250@0.0}
                      loopStart: 2 loopEnd: 4).
]]]

We note that an envelopg is characterized by a set of points and a loop. The associated method is ==points:loopStart:loopEnd: ==. A loop may as well use all the defined point or 1 alone.


For example here is added to the envelope with a loop indices from 2-4 (1 being the index value of the first table). The following sequence is performed for varying between 0.8 and 1 values. Sound volume seems to vibrate.
[[[
60@1.0. 110@0.8. 200@1.0
]]]

If we want to keep the volume at a certain level, we would write the envelope like this

[[[
sound addEnvelope: (VolumeEnvelope
                      points: { 0@0 . 60@1.0 . 110@0.8 . 200@1.0 . 250@0.0}
                      loopStart: 5 loopEnd: 5).
]]]

Le son se termine avec la valeur ==250@0.0== et une boucle maintenant le volume à 0 pendant toute sa durée.

Finalement, la méthode retourne le son avec comme paramètre la note (ici exprimée en Hz, voir tableau ""*frequence*""), la durée en seconde et un volume global de la note. Ce volume sera ensuite modulé grâce à l'enveloppe qui est définie.

[[[
^ sound setPitch: 440.0 duration: 1.0 loudness: 0.5
]]]


The sound ends with the value ==250@0.0== and a loop now the volume to 0 throughout its duration.

Finally, the method returns the sound with the note as a parameter (here expressed in Hz, see table *frequence*), the second term and an overall volume of the note. This volume is then modulated by the envelope is defined.

[[[
 ^ Sound SetPitch: 440.0 duration: 1.0 loudness: 0.5
]]]


@frequence

|!|Note|!|Octave
|| |!|-1|!|0|!|1|!|2|!|3|!|4|!|5|!|6|!|7
|!|C||16.3||32.7||65||131||262||523||1046.5||2093||4186
|!|C#||17.3||34.6||69||139||277||554||1109||2217||4435
|!|D||18.3||36.7||74||147||294||587||1175||2349||4698
|!|D#||19.4||38.9||78||156||311||622||1244.5||2489||4978
|!|E||20.5||41.2||83||165||330||659||1318.5||2637||5274
|!|F||21.8||43.6||87||175||349||698.5||1397||2794||5588
|!|F#||23.1||46.2||92.5||185||370||740||1480||2960||5920
|!|G||24.5||49.0||98||196||392||784||1568||3136||6272
|!|G#||26.0||51.9||104||208||415||831||1661||3322||6645
|!|A||27.5||55.0||110||220||440||880||1760||3520||7040
|!|A#||29.1||58.0||117||233||466||932||1865||3729||7458
|!|B||30.8||62.0||123||247||494||988||1975||3951||7902


!!How to play your own sound?

We'll show you how we will create our own sound.
Start by playing a ==A== follows:

[[[
(FMSound new setPitch: 440 duration: 1.0 loudness: 1) play
]]]


The sound is played at a frequency of 440 Hz for 1 second with a maximum volume.
The class ==FMSound== provides generation of sine tones. It gives a fairly smooth and even sound. Figure*sinusoide* below shows how the curve looks like.

+Sinusoïde produite>file://figures/sin.png|width=75|label=sinusoide+


One thing to know is that instead of defining a note by its frequency we can write in the English notation. Table @frequence   shows that an A at octave 4 has a frequence of 440Hz. 

Therefore to produce an A we can now write it as the following:

[[[
(FMSound new setPitch: 'a4' duration: 1.0 loudness: 1) play
]]]

We can also generate other notes.

[[[
(FMSound new setPitch: 'g#4' duration: 1.0 loudness: 1) play
]]]


!! Playing several sounds in sequence

Playing a sound is good, but two is even better. For that we have at our disposal a class named ==SequentialSound==. As the name suggests we can play sounds in sequence.

[[[
| seq |
seq := SequentialSound new.
seq add: (FMSound new setPitch: 'g#4' duration: 0.5 loudness: 1).
seq add: (FMSound new setPitch: 'a3' duration: 0.5 loudness: 1).
seq add: (FMSound new setPitch: 'g#4' duration:0.5 loudness: 1).
seq play.
]]]

If we listen to the sounds generated, we can perceive a small clap transitions between each note. To avoid this we will apply a volume envelope on each note. This is done as follows:

[[[
points := { 0@0 . 10@1 . 400@0.4 . 500@0}.
]]]

The played note is at its maximum at the beginning and then gradually returns to 0 after 500ms. The envelope is defined for a period equal to the duration of the note transition occurs naturally and sounds better to the ear.


See what gives our previous code with a volume envelope

[[[
| seq snd1 snd2 snd3 points |
"Sounds creation"
seq := SequentialSound new.
snd1 := FMSound new.
snd2 := FMSound new.
snd3 := FMSound new.

"Volume creation"
points := { 0@0 . 10@1 . 400@0.4 . 500@0}.

"Generation of notes"
snd1 setPitch: 'g#4' duration:0.5 loudness: 1.
snd2 setPitch: 'a3' duration:0.5 loudness: 1.
snd3 setPitch: 'g#4' duration:0.5 loudness: 1.

"Application  of envelope to sounds"
snd1 addEnvelope: (VolumeEnvelope points: points loopStart: 4  loopEnd: 4).
snd2 addEnvelope: (VolumeEnvelope points: points loopStart: 4  loopEnd: 4).
snd3 addEnvelope: (VolumeEnvelope points: points loopStart: 4  loopEnd: 4).

seq add: snd1.
seq add: snd2.
seq add: snd3.

"Playing"
seq play.
]]]

The sequence is now more pleasant to listen to.



!!Playing several sounds simultaneously 

Play sounds in sequence but it is still not enough to give a soul to our production. For this we will use class ==MixedSound==.
It will literally mixing several sounds at the same time.


[[[
| mix snd1 snd2 points |
mix := MixedSound new.
snd1 := FMSound new.
snd2 := FMSound new.

points := { 0@0 . 10@1 . 400@0.4 . 500@0}.

snd1 setPitch: 'a4' duration:1 loudness: 1.
snd2 setPitch: 'a3' duration:1 loudness: 1.

snd1 addEnvelope: (VolumeEnvelope points: points loopStart: 4  loopEnd: 4).
snd2 addEnvelope: (VolumeEnvelope points: points loopStart: 4  loopEnd: 4).

mix add: snd1 pan: 0; add: snd2 pan: 1.

mix play.
]]]


Let's modify some values of the attack using the method ==setPitch: duration: loudness:== for different notes and familiarize ourselves with the messages. The volume change of the envelope curve of the sound over time and can be used to obtain special effects.

For example if we wanted to add an echo effect to our sound should change the points of the envelope volume

[[[
points := { 0@1 . 100@0.6  . 200@0 . 300@0.2 . 400@0.1 . 500@0 }.
]]]

and envelope definitions


[[[
snd1 addEnvelope: (VolumeEnvelope points: points loopStart: 6  loopEnd: 6).
snd2 addEnvelope: (VolumeEnvelope points: points loopStart: 6  loopEnd: 6).
]]]

In our example we also use the message  ==pan:== that will position the sound in stereo. ==0== for left and ==1== for right. A value of  ==0.5== places the sound in the middle.

We will reuse the example above and add stereo to it.
[[[
| mix seq1 seq2 seq3 snd1 snd2 snd3 points rest rest2 |

mix := MixedSound new.
rest := RestSound new.
rest2 := RestSound new.
seq1 := SequentialSound new.
seq2 := SequentialSound new.
seq3 := SequentialSound new.
snd1 := FMSound new.
snd2 := FMSound new. 
snd3 := FMSound new.

points := { 0@1 . 400@0.4 . 500@0}.

snd1 setPitch: 'g#4' duration:0.5 loudness: 1.
snd2 setPitch: 'a3' duration:0.5 loudness: 1.
snd3 setPitch: 'g#4' duration:0.5 loudness: 1.
rest duration: 0.5.
rest2 duration: 0.5.

snd1 addEnvelope: (VolumeEnvelope points: points loopStart: 3  loopEnd: 3).
snd2 addEnvelope: (VolumeEnvelope points: points loopStart: 3  loopEnd: 3).
snd3 addEnvelope: (VolumeEnvelope points: points loopStart: 3  loopEnd: 3).

seq1 add: snd1.
seq2 add: rest; add: snd2.
seq3 add: rest; add: rest2; add: snd3.

mix add: seq1 pan: 0.
mix add: seq2 pan: 0.5.
mix add: seq3 pan: 1.

mix play.
]]]

In this new example, we introduced a new class of its ==RestSound== to create a silence.
It has only one message ==duration:== expressed in seconds.

The class ==SequentialSound==  has a limitation. Look at the following example to see what happens


[[[
| seq snd1 snd2 snd3 |
seq := SequentialSound new.
snd1 := FMSound new.
snd2 := FMSound new.
snd3 := FMSound new.

snd1 setPitch: 'g#4' duration:0.5 loudness: 1.
snd2 setPitch: 'a3' duration:0.5 loudness: 1.
snd3 setPitch: 'g#4' duration:0.5 loudness: 1.

seq add: snd1.
seq add: snd2.
seq add: snd3.
seq add: snd2.

seq play.
]]]

Normally we shauld hear 4 sounds played in sequence, or there are only 3. Obviously we can not reuse the already used. This approache is not suitable for what we want to do. For this there is another class that will meet our needs: ==QueueSound==

Replace the line ==seq := SequentialSound == by == seq := QueueSound == and listen again our example. We listen well our 4 sounds. Voila!


!!Envelopes

We introduced a first envelope which acts on the volume of a sound. There is another that changes the note or rather its frequency as it is played. This is called the attack of the note, the pitch in English.

In the same way as for the volume we will define a set of points which indicates the time of change of the sound frequency. The higher the value, the higher the rating will be high. If a negative number is indicated, the rating drops below the starting note. We define an envelope but this time using the class ==PitchEnvelope==.

[[[
| snd p |
p := { 0@0 . 100@0.1 . 200@0.2 . 300@(-0.5) . 400@0.7 . 800@0.8 . 1000@1 }.
snd := FMSound new.
snd addEnvelope: (PitchEnvelope points: p loopStart: 7  loopEnd:7).
(snd setPitch: 'a4' duration: 2 loudness: 0.5) play.
]]]


The transition between different frequencies is smooth and without cracks. We will add to this a volume envelope to produce a more interesting sound .

[[[
| snd p p2 |
p := { 0@0 . 100@0.1 . 200@0.2 . 300@(-0.5) . 400@0.7 . 800@0.8 . 1000@1 }.
p2 := { 0@0 . 100@0.1 . 200@0.2 . 300@(-0.5) . 400@0.7 . 800@0.8 . 1000@0 }.
snd := FMSound new.
snd addEnvelope: (PitchEnvelope points: p loopStart: 7  loopEnd: 7).
snd addEnvelope: (VolumeEnvelope points: p2 loopStart: 7  loopEnd: 7).
(snd setPitch: 'a4' duration: 2 loudness: 0.5) play.
]]]


The volume varies a lot in our example because all the points have been set manually. Now imagine that we wanted to gradually reduce to 0. We would have to define a number of points to produce a decreasing curve. It is doable, but it is tedious and the curve may not produce the desired effect. Instead of this manual approach, we will use a message called  ==exponentialDecay:== of ==VolumeEnvelope==  for the volume or class ==PitchEnvelope==  for the pitch. The curve exponentially starts with the highest volume and arrive smoothly to 0.

The definition of volume becomes this:

[[[
snd addEnvelope: (VolumeEnvelope exponentialDecay: 0.9).
]]]

The value must be strictly greater than 0 and smaller than 1. To know the points generated just select the following expression  and select the print it menu item. 

[[[
(VolumeEnvelope exponentialDecay: 0.2) points.
]]]

We get the following result

[[[
{(0@0.0). (10@1.0). (20@0.2). (30@0.04000000000000001). (50@0.0)}
]]]

The higher the value, the greater the number of values​is important. We can visualize what it is like our shell by opening the  ==EnvelopeEditorMorph== like this: 

[[[
EnvelopeEditorMorph new openInWorld
]]]


Select the entire line and do "right/Do it click." A window appears as shown in Figure  *EnvelopeEditorMorph*.

+Envolpe Editor>file://figures/envelopeEditorMorph.png|width=75|label=EnvelopeEditorMorph+

You can enlarge it by selecting it with ""shit + right click"" then moving the anchor at the bottom right of the window as shown in Figure *EnvelopeEditorMorphAnchor*

+Anchor>file://figures/envelopeEditorMorphAnchor.png|width=75|label=EnvelopeEditorMorphAnchor+


 The Editor exposes the curves of the instrument and allows us to change the points. You can switch from one curve to the other is by selecting directly in the window, or by selecting it from the menu ==editing== at the bottom left of the editor.

In abscissa we have the time in milliseconds. The ordinate is modified in accordance with the selected curve. We also have 3 boundaries represented by the vertical orange axes. The two on the left are used for loop when the note is held, are the parameters ==loopStart:loopEnd:==. Rightmost is when the note is released. We can also move according to our needs using the orange triangles above the curve abscissa. Note that it is not possible with the editor to have a loop of less than 50ms duration, as it is not possible to have a loop start value different from the value end. Which makes sense if we want to get a smooth loop.

To add a point on a portion of the curve just click on the little green triangles to display the corresponding point. This point can then move to be positioned at the desired value. We invite you to test all these possibilities and listen to the result obtained with the piano keyboard available. Envelopes complement our knowledge on the generation of sound. So we know play a sound, more sounds one after the other or several played simultaneously.


!!Playing a melody

A quoi peut bien ressembler de la musique produite dans Pharo ? Evaluons la ligne de code suivante dans un workspace et écoutons.

[[[
FMSound bachFugue play
]]]

La musique est constituée d'une séquence de notes. Nous savons maintenant comment écrire une telle séquence mais pour une mélodie entière ce n'est pas adapté. Il est nécessaire de faire autrement.

Nous allons décrire l'ensemble des notes dans un tableau. Le format est le suivant

[[[
(note duree volume)
]]]

La note peut être écrite sous sa forme littérale ou d'après sa fréquence en hertz. La durée s'exprime en millisecondes. Le volume quant à lui est une valeur entre 0 et 1000. Au delà de 1000 le son peut être amené à saturer mais cela peut se révéler utile dans certains cas pour donner un effet.

Voici un exemple de déclaration d'une séquence

[[[
notes := #((a3 200 150) (a4 100 150) (g3 150 150))
]]]

Nous allons écrire notre premier morceau avec un air qui devrait rappeler des bons souvenirs à tout ceux qui aiment le début de l'air des jeux vidéos. Nous allons définir la mélodie d'introduction du jeu pacman.

!!! New element definition

Commençons par définir un nouvel instrument. Afin de ne pas compliquer notre exercice, nous allons utiliser la classe ==FMSound== dans laquelle nous allons définir quelques nouvelles méthodes. Notez que pour être plus propre et modulaire, nous devrions définir notre propre package et classes. 

Pour définir une méthode nous allons utiliser un navigateur de classe: Pour cela 

- ouvrez le SystemBrowser depuis le menu Tools
- trouvez la classe ==FMSound== en utilisant l'item Find Class du menu de la liste la plus à gauche (la liste des packages)

Vous devez obtenir un navigateur comme celui de la figure *systemBrowser*

+System browser: un navigateur de classes>file://figures/SystemBrowser.pdf|width=100|label=systemBrowser+

Comme les méthodes que nous définissons sont des méthodes qui créent des instances de ==FMSound== par opposition à des méthodes qui agissent sur des instances de la classe ==FMSound== nous allons les définir sur le coté classe de la classe ==FMSound==. Pour cela:

- cliquez sur le radio bouton 'Class side'
- à l'aide du menu de la troisième liste en partant de la gauche (liste des protocoles de méthodes - il s'agit de simple classeurs de rangement), ajoutez un protocole nommé par exemple 'new instruments'.
- sélectionner le nouveau protocole puis ajouter la méthode ==fm1== suivante. Pour ajouter une méthode, tapez le corps de la méthode puis utiliser l'entrée 'Accept' qui compile la méthode. 

[[[
fm1
	| snd |
	snd := self new.
	snd addEnvelope: (VolumeEnvelope points: { 0@1 . 300@0 }
					 				 loopStart: 2
									 loopEnd: 2).
	snd modulation: 1 ratio: 2.
	^ snd
]]]

Vous devez obtenir une situation similaire à celle présentée par la figure *fm1*

+System browser sur une méthode de classe>file://figures/fm1.pdf|width=100|label=fm1+

Vérifiez que votre nouvel instrument fonctionne en executant ==FMSound fm1 play==.

Nous allons définir un autre instrument en copiant celui-ci afin de vous permettre d'expérimenter. 

[[[
fm2
	| snd |
	snd := self new.
	snd addEnvelope: (VolumeEnvelope points: { 0@1 . 300@0 }
					 				 loopStart: 2
									 loopEnd: 2).
	snd modulation: 1 ratio: 2.
	^ snd
]]]

Déclarons maintenant, la méthode permettant de mixer l'ensemble des pistes qui vont être créées à l'aide des méthodes ==pacmanV10:== et ==pacmanV20:==.

[[[
FMSound class>>pacman
	"comment stating purpose of message"

	^ MixedSound new 
		add: (self pacmanV1On: self fm1) pan: 0.5;
		add: (self pacmanV2On: self fm2) pan: 0.5.
]]]

Les deux méthodes suivantes contiennent l'ensemble des notes à jouer avec le triplet note, durée et volume.

[[[
FMSound class>>pacmanV1On: aSound

	| notes |
	notes := #(
        (b4 0.144 150) (b5 0.144 150) ('f#5' 0.144 150) ('d#5' 0.144 150)
        (b5 0.072 150) ('f#5' 0.144 150) ('d#5' 0.288 150) (c5 0.144 150)
        (c6 0.144 150) (g5 0.144 150) (e5 0.144 150) (c6 0.072 150)
        (g5 0.216 150) (e5 0.288 150) (b4 0.144 150) (b5 0.144 150)
        ('f#5' 0.144 150) ('d#5' 0.144 150) (b5 0.072 150) ('f#5' 0.216 150)
        ('d#5' 0.288 150) ('d#5' 0.072 150) (e5 0.072 150) (f5 0.144 150)
        (f5 0.072 150) ('f#5' 0.072 150) (g5 0.144 150) (g5 0.072 150)
        ('g#5' 0.072 150) (a5 0.144 150) (b5 0.216 150)).

        ^self noteSequenceOn: aSound from: notes.
]]]

La méthode ==noteSequenceOn:from:== va générer une séquence de notes (par exemple SequentialSound) à partir d'un tableau de notes pour un instrument donné. Elle va utiliser comme vu précédemment le triplet note, durée, volume.

[[[
FMSound class>>pacmanV2On: aSound
	| notes |
	notes := #(
        (b1 0.432 500) (b2 0.144 500) (b1 0.432 500) (b2 0.144 500) (c2 0.432 500)
        (c3 0.144 500) (c2 0.432 500) (c3 0.144 500) (b1 0.432 500) (b2 0.144 500)
        (b1 0.432 500) (b2 0.144 500) ('f#2' 0.288 500) ('g#2' 0.288 500)
        ('a#2' 0.288 500) (b2 0.288 500)).

        ^self noteSequenceOn: aSound from: notes.
]]]

Si votre mélodie utilise des notes à fréquence basse, le volume de celle ci sera difficilement audible. Vous pouvez alors pour y remédier augmenter le volume des notes. Ici nous sommes passé à un volume de 500, contrairement à la précédente mélodie où nous étions resté à 150.

Voila il ne reste plus qu'à exécuter la mélodie: ==FMSound pacman play==.

!!Playing a sample

La sonorisation d'une production ne passe pas essentiellement par de la synthèse sonore, parfois il est nécessaire de faire appel à des sons digitalisés reproduisant des bruitages, des voix ou des musiques entières. Nous allons vous montrer comment jouer un sample à partir d'un fichier ou directement depuis la mémoire.

Tout d'abord nous allons télécharger les sons pour notre exemple. Pour cela exécuter dans une console la commande suivante ou alors téléchargez directement l'archive sur votre ordinateur.

[[[
wget https://github.com/xmessner/PharoSoundTutorial/archive/master.zip
]]]

Décompressez la ensuite dans le répertoire de votre choix. Le sous-répertoire ==sounds== contient l'ensemble des sons digitalisés de l'article dont nous aurons besoin.

Il vous faudra adapter les répertoires de dépôt en fonction de votre environnement.

Essayons dans un premier temps de jouer un son à partir d'un fichier au format wav.

[[[
(SampledSound fromWaveFileNamed: '/home/messner/sound.wav') play
]]]

Le son est joué en tâche de fond sans bloquer le reste de notre environnement. Nous pouvons par exemple utiliser cette méthode pour sonoriser une action ponctuelle ou une alerte.

Si notre but était de concevoir un jeu, le chargement du son directement depuis le disque à des moments clés risquerait de ralentir les animations voir de le rendre injouable. Afin d'éviter ces petits désagréments les sons seront chargés en mémoire et joués lorsque ce sera nécessaire pour gagner en temps de réponse.

Pharo met à notre disposition une banque de sons que nous pouvons alimenter suivant nos besoins. Pour rajouter un son à cette librairie nous utiliserons le message ==addLibrarySoundNamed:samples:samplingRate:==. 
@@todo on devrait ajouter une methode ==addLibrarySoundNamed:== qui appelle addLibrary avec samples et originalSamplingRate
@@todo à corriger après la revue
@@todo rajouter un exemple pour lister le contenu de la librairie si on peut ... mais oui on peut :)

Dans un workspace copiez le code suivant et évaluez-le pour rajouter le sample dans la librairie

[[[
| spl spl2 |
"Chargement du son a partir d'un fichier"
spl := SampledSound fromWaveFileNamed: '/home/messner/guitar.wav'.

"Ajout du son dans la librairie pour le jouer plus tard"
SampledSound addLibrarySoundNamed: 'guitar'
             samples: spl samples
             samplingRate: spl originalSamplingRate.
]]]

Maintenant nous pouvons jouer le sample à la fréquence et à la durée souhaitée

[[[
| spl spl2 |
spl := SampledSound soundNamed: 'guitar'.
spl2 := (SampledSound samples: spl samples samplingRate: 2000).
spl2 duration: 0.1.
spl2 play.
]]]

@@todo estil possible de le jouer a la vitesse ou il a ete enregistre? il me semble que oui avec originalSamplingRate. Il faut que je fasse le test sur un sample plus significatif.

!!A last ittle effort 

Nous allons clore cet article sur une dernière méthode permettant de jouer plusieurs sons digitalisés en séquence.

Dans un premier temps nous allons charger en mémoire les différents samples qui seront utilisés.

[[[
| spl spl1 spl2 |
"Chargement des sons"
spl := SampledSound fromWaveFileNamed: '/home/messner/ocean.wav'.
spl1 := SampledSound fromWaveFileNamed: '/home/messner/mouette.wav'.
spl2 := SampledSound fromWaveFileNamed: '/home/messner/bateau.wav'.

"Ajout des sons dans la librairie pour les jouer plus tard"
SampledSound addLibrarySoundNamed: 'ocean'
             samples: spl samples
             samplingRate: spl originalSamplingRate.
SampledSound addLibrarySoundNamed: 'mouette'
             samples: spl1 samples
             samplingRate: spl1 originalSamplingRate.
SampledSound addLibrarySoundNamed: 'bateau'
             samples: spl2 samples
             samplingRate: spl2 originalSamplingRate.
]]]

@@todo on doit ameliorer fromWaveFileNamed: pour lui passer un fileSystem FileSystem disc workingDirectory / 'ocean.wav'

Maintenant que tous nos sons sont chargés nous allons les jouer en séquence grâce à la classe ==QueueSound== vue précédemment. Ils sont joués les uns après les autres à la fréquence souhaitée.

[[[
| mix q1 q2 spl1 spl2 spl3 |

q1 := QueueSound new.
q2 := QueueSound new.
mix := MixedSound new.
spl1 := (SampledSound samples: (SampledSound soundNamed: 'ocean')
                      samples samplingRate: 22000).
spl1 duration: 20.
spl2 := (SampledSound samples: (SampledSound soundNamed: 'mouette')
                      samples samplingRate: 22000).
spl2 duration: 10.
spl3 := (SampledSound samples: (SampledSound soundNamed: 'bateau')
                      samples samplingRate: 22000).
spl3 duration: 5.

q1 add:spl2;add:spl2.
q2 add:spl3;add:spl3.
mix add: q1 pan: 0 volume: 0.100;
    add: q2 pan: 1 volume: 0.5;
    add: spl1 pan: 0.5 volume: 1.
mix play.
]]]

!! Conclusion

Nous vous avons montré une petite partie des possibilités que Pharo offre pour la création et manipulations des sons. Nous espérons vous avoir donner envie d'expérimenter. 





 



% Local Variables:
% eval: (flyspell-mode -1)
% End:
