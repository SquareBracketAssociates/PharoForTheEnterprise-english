! TaskIT

TaskIT is a library to enable the usage of processes in Pharo. TaskIt is in charge of helping with the schedulling and/or parallelization of the execution of pieces of code inside Pharo.

!! Downloading

A metacello configuration of TaskIT is available in smalltalkhub using the following code.

[[[
Gofer it 
	smalltalkhubUser: 'sbragagnolo' project: 'TaskIT';
	configurationOf: 'TaskIT';
	loadVersion: #bleedingEdge
]]]

!!Creation of a TKTTask

A ==TKTTask== can be created for mainly blocks in the following way:
[[[
TKTTask for: [ ].
TKTTask for: [ ] at: aPriority.
]]]
When a priority is not explicitly provided, it uses the ==userBackgroundPriority== defined in the ==ProcessorScheduler==.

Alternatively, blocks are extended to provided a nice syntax sugar to create tasks:

[[[
[ ] asTask.
[ ] asTaskAt: aPriority.
]]]


!!Executing a TKTTask

To execute a task we need to send the message ==doIt== to the task.

[[[
[ 2 +  2 ] asTask doIt.
]]]

or as well,

[[[
[ 2 + 2 ] doIt.
]]]

The message ==doIt== will execute the task as a new pharo process. As this execution can last some time, the immediate result of the ==doIt== message is a ==TKTFuture== object. To obtain the final value of the execution of the future we can ask it if its value is available with ==isValueAvailable==, or we can ask for its value directly. Notice that sending the ==value== message to a future object we will block the execution of the caller process until the execution of the task is finished, either by an error or an expected result.

[[[
[ 2 + 2 ] doIt isValueAvailable.
[ 2 + 2 ] doIt value.
]]]

!!Synchronous and Asynchronous execution via futures

A TKTFuture object is the promise of an execution's result. A TKTFuture can hold an error produced by the task execution, the value of the finished execution, or none if the task has not yet finished.

The value promised by the future can be obtained both synchronous and asynchronously. 

!!!Synchronous execution
To obtain the TKTFuture value synchronously we send it the #value message. Synchronous access to the value will block the caller's process until the result is available.

[[[
[ 20 benchFib ] doIt value.
]]]

!!!Aynchronous execution with callbacks

Support for asynchronous execution is provided via callbacks. A callback is a block with zero or one argument that will hold the value resultant from the task execution. A callback can be added to a future with the #whenFinished: message. A TKTFuture supports the addition of many different callbacks.

[[[
[ 40 benchFib ] doIt whenFinished: [ :result | result logCr ].
]]]

Note: On the one hand, the callbacks registered while the task is not yet finished will be executed on the process of the task when it finishes. On the other hand, callbacks registered while the task is already finished will be executing in the caller thread with the already available result.

!!!Lazy result resolution

A third way to work with futures is to ask it for a lazy result. A lazy result is an object that will transform itself. Show how to synchronize two tasks.

Think about an example where this is useful.
[[[
[ 20 benchFib ] doIt asResult.
]]]

!!Organizing Tasks with Workers

!!TODOs

- cleanup wtF?
- no perder stack del error en TKTFuture value
- TKTFuture>>isProcessFinished wtf
- Think that maybe we need timeouts for synchronous future evaluation.
- refactor Worker -> Worker OneShotworker y StreamWorker (volar sticky future en el camino)

% Local Variables:
% eval: (flyspell-mode -1)
% End:
