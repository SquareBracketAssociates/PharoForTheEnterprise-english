! TaskIT

Expressing and managing concurrent computations is indeed a concern of importance to develop applications that scale. A web application may want to use different processes for each of its incoming requests. Or maybe it wants to use a "thread pool" in some cases. In other case, our desktop application may want to send computations to a worker to not block the UI thread.

TaskIT is a library that eases the usage of processes in Pharo. It provides abstractions to schedule and/or parallelize of the execution of pieces of code. In this chapter we will explore these abstractions, guided by examples and code snippets.

!! Downloading

A metacello configuration of TaskIT is available in smalltalkhub using the following code.

[[[
Gofer it 
	smalltalkhubUser: 'sbragagnolo' project: 'TaskIT';
	configurationOf: 'TaskIT';
	loadVersion: #bleedingEdge
]]]

!!Creation of a TKTTask

A task is a first class representation of a piece of code to be executed. Reifying the idea of task allows us to manage it: paralellize it, start it and/or stop it whenever we want. A task, instance of ==TKTTask==, can be created from a block in the following way:

[[[
TKTTask for: [ someObject someMessage ].
TKTTask for: [ someObject someMessage ] at: aPriority.
]]]
When a priority is not explicitly provided, it uses the ==userBackgroundPriority== defined in the ==ProcessorScheduler==.

Alternatively, blocks are extended to provided a nice syntax sugar to create tasks:

[[[
[ someObject someMessage ] asTask.
[ someObject someMessage ] asTaskAt: aPriority.
]]]


!!Executing a TKTTask

To execute a task we need to send the message ==doIt== to the task. The message ==doIt== will fork the execution of the task in a new Pharo process. Tipically, a Pharo process is removed from the system once finished, forbidding us to obtain the result of it's execution. TaskIT provides us with a way to obtain the result of our processes in many different ways by using futures.

[[[
[ 2 +  2 ] asTask doIt.
]]]

or as well,

[[[
[ 2 + 2 ] doIt.
]]]


!!Obtaining a Task's Result with Futures.

As this execution can last some time, the immediate result of the ==doIt== message is a future object, instance of ==TKTFuture==. A TKTFuture object is the promise of an execution's result. A TKTFuture can hold an error produced by the task execution, the value of the finished execution, or none if the task has not yet finished.

[[[
aFuture := [ 2 + 2 ] doIt.
]]]

Once we have a future in our hands, we can retrieve its value both synchronously and asynchronously, and interact with it in many forms.

!!!Synchronous execution

The simplest way to interact with our future is synchronously. That is, when asking for a future's value, it will block the actual process until the value is available. We can do that by sending our future the message ==value==.

[[[
future := [ 2 + 2 ] doIt.
self assert: future value equals: 4.
]]]

However, it could have been possible for our task to be finished in an erroneous state, with an exception. In such case, the exception that was thrown inside the task's execution is forwarded to the sender of ==value==.

[[[
future := [ SomeError signal ] doIt.
[ future value ] on: SomeError do: [ :error | "We handle the error" ].
]]]

A future can also tell us if the task is already finished or not, by sending it the message ==isValueAvailable==. The ==isValueAvailable== message, opposed to the ==value== message, will not block the caller's process but return immediately a boolean informing if the task has finished.

[[[
future := [ 2 + 2 ] doIt.
future isValueAvailable.
]]]

However, waiting synchronously for the task to be finished can be a waste of CPU time or a bad usage of resources. TaskIT provides for those cases when completely synchronous execution does not fit the alternative of retrieving a value with a timeout option, using the ==valueTimeoutMilliseconds:== message. When we specify a timeout, we can also provide a block to handle the timeout case using the ==valueTimeoutMilliseconds:ifTimeout:==. If we choose not to provide such a block, a ==TKTTimeoutError== exception will be raised by the future.

[[[
future := [ (Delay forMilliseconds: 100) wait ] doIt.

future valueTimeoutMilliseconds: 2 ifTimeout: [ "if it times out we execute this block"].

future valueTimeoutMilliseconds: 2.
]]]

!!!Aynchronous execution with callbacks

Support for asynchronous execution is provided via callbacks. A callback is a block with zero or one argument that will hold the value resultant from the task execution. A callback can be added to a future with the #whenFinished: message. A TKTFuture supports the addition of many different callbacks.

[[[
[ 40 benchFib ] doIt whenFinished: [ :result | result logCr ].
]]]

Note: On the one hand, the callbacks registered while the task is not yet finished will be executed on the process of the task when it finishes. On the other hand, callbacks registered while the task is already finished will be executing in the caller thread with the already available result.

!!!Lazy result resolution

A third way to work with futures is to ask it for a lazy result. A lazy result is an object that will transform itself. Show how to synchronize two tasks.

Think about an example where this is useful.
[[[
[ 20 benchFib ] doIt asResult.
]]]

!!Creating Custom Tasks

!!Special Task Runners

!!Organizing Tasks with Workers

!!ActIT: A Simple Actor Library on top of TaskIT

!!Conclusion

!!TODOs

- interruptCurrentTask

	currentTask ifNotNil: [ 
		currentTask value isProcessFinished ifFalse: [
			currentTask  priority: 10.
			workQueue do: currentTask.
		].
	].
- cleanup wtF?
- por que hay que ejecutar esto en un task?
self scheduleTask: [ keepRunning set: false ] asTask.


% Local Variables:
% eval: (flyspell-mode -1)
% End:
