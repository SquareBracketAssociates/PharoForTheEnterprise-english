





!!First User Classes: ObjPoint and ColoredObjPoint}
Now ObjVLisp is created and we can start to program some classes. 
Implement the class ==ObjPoint} and ==ObjColoredPoint} as 
follow. 

!!!==ObjPoint}}

You can choose to implement it at the class level of the class Obj.


       - First just create the class ==ObjPoint}. 
       - Create an instance of the class ==ObjPoint}.
       - Send some messages defined in ==ObjObject} to this instance. 


Define the class Point so that we can create points as follows:

[[[
aPoint := pointClass send: #new withArguments: #((#x: 24 #y: 6)).
aPoint binarySend: #getIV with: #x.
aPoint send: #setIV withArguments: #(#x 25).
aPoint binarySend: #getIV with: #x.
]]]

\noindent Then add some functionality to the class ==ObjPoint} like 
==x}, ==x:}, ==display} which prints the receiver. 

%[[[
%ObjPoint addMethod: #x
%       withBody: [:objself \ttt{|} objself binarySend: #getIV with: #x].

%ObjPoint addMethod: #x:
%       withBody: [:objself :val \ttt{|} objself send: #setIV withArguments: (Array with: #x with: val)].

%ObjPoint addMethod: #display
%       withBody:  [:objself \ttt{|} 
%                          Transcript cr; show: 'aPoint with x = '.
%                          Transcript show: (objself unarySend: #x) printString; cr].
%]]]

\noindent Then test these new functionality.

[[[                         
aPoint unarySend: #x.
aPoint binarySend: #x: with: #(33).
aPoint unarySend: #display            
]]]                  


!!!==ObjColoredPoint}}


\noindent Define the class ==ObjColored}.
%[[[
%\ttt{|} coloredPointClass aColoredPoint \ttt{|}
%ObjClass send: #new
%       withArguments: #((#name: #ObjColoredPoint 
%                        #iv: #(#color) 
%                        #superclass: #ObjPoint)).
%]]]

\noindent Create an instance and send it some basic messages. 

[[[
aColoredPoint := coloredPointClass
                    send: #new 
                    withArguments: #((#x: 24 #y: 6 #color: #blue)).      
             
aColoredPoint binarySend: #getIV with: #x.
aColoredPoint send: #setIV withArguments: #(#x 25).
aColoredPoint binarySend: #getIV with: #x.
aColoredPoint binarySend: #getIV with: #color. 
]]]

\noindent Define some functionality and invoke them: the method color, 
implement the method display so that it invokes the superclass and adds some information 
related to the color. 


%coloredPointClass 
%            addMethod: #color
%            withBody: [:objself \ttt{|} objself binarySend: #getIV with: #color].

%coloredPointClass 
%            addMethod: #color:
%            withBody: [:objself :val \ttt{|} objself send: #setIV 
%                                           withArguments: (Array with: #color with: val)].

%coloredPointClass 
%            addMethod: #display
%            withBody: [:objself \ttt{|} 
%                  objself unarySuper: #display.
%                  Transcript cr;  show: ' with Color = '.
%                  Transcript show: (objself unarySend: #color) printString; cr].
[[[
aColoredPoint unarySend: #x.
aColoredPoint unarySend: #color.
aColoredPoint unarySend: #display
]]]


!!A First User Metaclass: ==ObjAbstract} }
Now implement the metaclass ==ObjAbstract} that defines instances (classes) that are abstract i.e., that 
cannot create instances. This class should raise an error when it executes the new message. 

%\easy{[[[
%\ttt{|}  abstractClass      \ttt{|} 
%abstractClass := #ObjClass
%                  send: #new
%                  withArguments: #(#(#name: #ObjAbstractClass 
%                               #iv: #() 
%                               #superclass: #ObjClass)).
%abstractClass addMethod: #new
%                  withBody: [:class :initArray \ttt{|}
%                          class error: ' the class ',class objName asString,' is abstract'].
%]]]}

Then the following shows you a possible use of this metaclass.
[[[
ObjAbstractClass send: #new
             withArguments: #(#(#name: #ObjAbstractPoint 
                          #iv: #() 
                            #superclass: #ObjPoint)).
                            
ObjAbstractPoint send: #new
             withArguments: #(#(#x: 24 #y: 6))             "should raise an error"
]]]

Note that the ==ObjAbstractClass} is an instance of ==ObjClass} because this is 
a class and inherits from of because this is a metaclass. 

%!!! Your Job. Implement the metaclass ==ObjSet} the metaclass that defines as class behavior the fact that a class knows its instances. 

!!Support: Classes inspecting}


To help you to implement ObjVLisp, we provide you an inspector
dedicated to the inspection of  ObjVLisp class objects. You can invoke this inspector 
sending the message ==debug} to an objInstance or sending the message ==classDebug:} to \inspector with the objInstance as parameter. Pay attention that the following code will not run because you should define the system first.


\begin{allsf}
\ttt{|} pointClass \ttt{|}
pointClass := Obj giveClassNamed: #ObjPoint.
pointClass debugClass. 
\end{allsf}


\begin{allsf}
\ttt{|}pointClass\ttt{|}
pointClass := Obj ObjPoint.
pointClass debugClass.
\end{allsf}

!!About error}
We defined message sending as in the methods ==send:withArguments:} as follows: we get the block corresponding to the selector and we execute it using the ==valueWithArguments:} message which expects an array containing the arguments of the block. 

\begin{allsf}
send: selector withArguments: arguments 
	"send the message whose selector is <selector> to the receiver. The arguments of the messages
	are an array <arguments>. The method is looked up in the class of the receiver. 
	self is an objObject or a objClass."

	| ans |
	ans := (self objClass lookup: selector for: self)
				valueWithArguments: (Array with: self), arguments.
	^ ans
\end{allsf}

The lookup method can be defined as follows:


\begin{allsf}
lookup: selector for: anObjObject
    "look for the method named <selector> starting in the receiver.
    The lookup is done for a message sent to <anObjObject>. self is an objClass"
   
    ^(self doesUnderstand: selector)
        ifTrue:
            [ self bodyOfMethod: selector]
        ifFalse:
            [self objName = #ObjObject
                ifFalse:
                    [ (Obj giveClassNamed: self objSuperclassId) lookup: selector for: anObjObject.]
                ifTrue: [ anObjObject objClass lookup: #error for: anObjObject]]
\end{allsf}

Finally the error method in ObjVlisp is defined as follows in the bootstrap

\begin{allsf}
objObject 
		addMethod: #error
		args: 'selector'
		withBody: 'Transcript show: ''error '', selector'.
\end{allsf}

Now everything works well except the error handling. Why? Because we can have a mismatch between the number of arguments that the method except and that the error block expect. For example in the case of an unary send, the unary send value passing one single object while the error ObjVlisp method expect two. The problem is that we do not have simple ways to make sure that we will be handling all the cases. For example using ==cull:} instead of ==value:} does not solve the problem.

To solve the problem we have to change the lookup as follows: we return nil when we do not find the method and we do not return directly the error method. 

\begin{allsf}
lookup: selector for: anObjObject 
	"look for the method named <selector> starting in the receiver. 
	The lookup is done for a message sent to <anObjObject>. self is an objClass"
	
	^(self doesUnderstand: selector)
		ifTrue: 
			[ self bodyOfMethod: selector]
		ifFalse: 
			[self objName = #ObjObject
				ifFalse: 
					[ (Obj giveClassNamed: self objSuperclassId) lookup: selector for: anObjObject.]
				ifTrue: [ nil ]]
\end{allsf}

We change accordingly the ==send:withArguments:} message:

\begin{allsf}
send: selector withArguments: arguments 
	"send the message whose selector is <selector> to the receiver. The arguments of the messages are an array <arguments>. The method is lookep up in the class of the receiver. self is an objObject or a objClass."

	^ self basicSend: selector withArguments: arguments from:  self objClass
	 
basicSend: selector withArguments: arguments from: aClass
	| methodOrNil |
	methodOrNil := (aClass lookup: selector for: self).
	^ methodOrNil 
		ifNotNil: [ methodOrNil valueWithArguments: (Array with: self) , arguments ] 
		ifNil: [ self sendError: selector withArgs: arguments ] 
\end{allsf}

Here we see that we perform a lookup and when the method is not found we send the error message to the receiver using the method ==sendError:withArgs:} which is defined as follows: 

\begin{allsf}
sendError: selector withArgs: arguments
	"send error wrapping arguments into an array with the selector as first argument. Instead of an array we should create a message object."
	
	^ self send: #error withArguments: {(arguments copyWithFirst: selector)}
	
\end{allsf}




{\small
\bibliographystyle{alpha}
\bibliography{/home/famoos/FamoosHandBook/famoos,/home/famoos/FamoosHandBook/famoos1,/home/famoos/FamoosHandBook/main}}
\end{document}


% Local Variables:
% coding: utf-8
% mode: latex
% TeX-master: t
% TeX-PDF-mode: t
% ispell-local-dictionary: "english"
% End:
