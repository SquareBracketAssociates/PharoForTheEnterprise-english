! Building ObjVlisp a Minimal, Uniform and Reflective Object-Oriented Language Kernel

This tutorial written by St√©phane Ducasse will step by step guide you to build 
the kernel of the ObjVLisp model. ObjVlisp was designed by P. Cointe as got inspired by the kernel 
of Smalltalk 78. It has explicit metaclasses and it is composed of two classes ==Object== and ==Class==.

!!Objectives
During the lecture you saw the main points of the ObjVLisp model, now you 
will implement it. The goals of this implementation are to give a 
concrete understanding of the concepts presented in the lecture. Here 
are some of the points you can deeply understand while doing the exercise.

- What is a possible object structure?
- What is object  allocation and initialization?
- What is class initialization?
- What the semantics of the method lookup?
- What is a reflective kernel?
- What are the roles of the classes \stc{Class== and \stc{Object==?
- What is the role of a metaclass? 


!!Before Starting
In this section we discuss the files that you will use, the implementation choices and the conventions that we will follow during 
all this tutorial. 

!!!Provided Files.
You need to download and install Pharo from *http://www.pharo.org/*. You need a virtual machine, and the couple image and changes. You can use *http://get.pharo.org* to get a script to download Pharo. You can use the book Pharo by Example from *http://www.pharo.org/PharoByExample/* for an overview of the syntax and the system. 

All the necessary files are provided as a Monticello package. It contains all the classes, the method categories and the method signatures of the methods that you have to implement. It provides additional functionality such as a dedicated inspector and some extra methods that will make your life easy and help you to concentrate on the essence of the model. It contains also all the tests of the functionality you have to implement. For each functionality you will have to run some tests.

For example to run a particular test named ==testPrimitive==, evaluate the following expression ==(ObjTest selector: #testPrimitiveStructure) run== or to click on the icon of the method named ==testPrimitiveStructure==.  

Note that since you are developing the kernel, to test it we implemented manually some mocks of the classes and kernel. This is the setup method of the test classes that build this fake kernel. Now pay attention because the setups are often taking shortcuts. 

To load the code open a monticello browser, add a file repository to point to the ObjVLispSkeleton project under ==StephaneDucasse== in ht eObjVLispSkeleton project at *http://www.smalltalkhub.com* and select and load the package.
 
To do this, use the following expression in the smalltalkhub repository creation pop up.

[[[
MCSmalltalkhubRepository
    owner: 'StephaneDucasse'
    project: 'ObjVLispSkeleton'
    user: ''
    password: ''
]]]

Select the latest file and load it. 
 
!!! Conventions. 
We use the following conventions: we name as ''primitives'' all the Pharo methods that participate 
in the building of ObjVLisp. These primitives are mainly implemented as methods of the class ==Obj==.  Note that in a Lisp implementation such primitives would be just lambda expressions, in a C implementation such primitives would be represented by C functions.

To help you to distinguish between classes in the implementation language (Pharo) and the ObjVLisp model, we prefix  all the ObjVLisp classes by ==Obj==. Finally, some of the crucial and confusing primitives (mainly the class structure ones) are all prefixed by ==obj==. For example the primitive that given an 'objInstance' returns its class identifier is named ==objClassId==.
We also talk about objInstances, objObjects and objClasses to refer to 
specific instances, objects or classes defined in ObjVLisp. 

!!! Inheriting from Array.

We do not want to implement a scanner, a parser and a compiler for ObjVLisp but concentrate on the essence of the language. That's why we chose to use as much as possible the implementation language, here Pharo. As Pharo does not support macro definition, we will use as much as possible the existing classes to avoid extra syntactic problems.

Every object in the ObjVLisp world is instance of ==Obj== in our implementation world (Pharo).
In Pharo ==Obj== is a subclass of ==Array==.

Since ==Obj== is a subclass of ==Array==, ==#(#ObjPoint 10 15)== is an objInstance of the class ==ObjPoint==. ==ObjPoint== is the name of an objClass.   ==#(#ObjClass #ObjPoint #ObjObject #(class x y) #(:x :y) nil )== is the array that represents the objclass  ==ObjPoint==.



!!! About representation choices.

We could have implemented ObjVLisp functionality at the class level of a class named ==Obj== inheriting only from ==Object==. However, to use the ObjVlisp primitive (a Pharo method) ==objInstanceVariableValue: anObject for: anInstanceVariable== that returns the value of the instance variable in ==anObject==, we would have been forced to write the following expression: 

[[[
Obj objInstanceVariableValue: 'x' for: aPoint
]]]

We chose to represent any ObjVLisp object by an array and to define the ObjVLisp functionality in the instance side of a subclass of ==Array== named ==Obj==. That way we can write in a more natural and readable way  the previous functionality as:

[[[
aPoint objInstanceVariableValue: 'x'.
]]]






!!! Facilitating ObjVLisp class access.
We need a way to declare, store and access ObjVLisp classes. As a
solution, on the class level of the Pharo class ==Obj== we defined a
dictionary holding the defined classes. This dictionary acts as the namespace for our language. We defined the following methods to store and access defined classes.

- ==declareClass: anObjClass== stores the instance of ==ObjClass== given as arguments in the class repository (here a dictionary whose keys are the names of the classes and values the ObjVLisp classes themselves).

- ==giveClassNamed: aSymbol== returns if it exists the ObjVLisp
class  named ==aSymbol==. The class should have been declared previously.


With such methods we can write code like the following one that looks for the class of the class ==ObjPoint==. 

[[[
Obj giveClassNamed: #ObjPoint
]]]

To make class access less heavy, we also implemented a shortcut: 
We trap messages not understood sent to ==Obj== and look into the defined class dictionary. 
Since ==ObjPoint== is an unknown message, this same code is then written as:

[[[
Obj ObjPoint
]]]

Now you are ready to start.




!!Structure and Primitives

The first issue is how to represent objects.  We have to agree on an initial representation. In this implementation we chose to represent the objinstances as arrays (instances of ==Obj== a subclass of ==Array==). In the following we used the terms array for talking about instances of the class ==Obj==.  

Note that we could extend the model so that the metaclasses support possible
instance structure changes  but in the current implementation
we will simply hardcode the class structure.

!!!! Your Job. 
Check that the class ==Obj== exists and  inherits from ==Array==. 


!!!Structure of a Class
As one of the first objects that we will create is the class ==ObjClass== we
focus now on the minimal structure of the classes in our language.  Given an
array  a class has the following structure: an identifier to its class, a name, 
an identifier to its superclass (we limit the model to single inheritance), a list of 
instance variables, a list of initialization keywords, and a method dictionary. 

For example the class ==ObjPoint== has then the following structure: 

[[[
#(#ObjClass #ObjPoint #ObjObject #(class x y) #(:x :y) nil ))
]]]


It means that ==ObjPoint== is an instance of ==ObjClass==, is named ==#ObjPoint==, inherits from a class named ==ObjObject==, has three instance variables, two initialization keywords and an uninitialized method dictionary. To access this structure we define some primitives.


!!!! Your Job. 
 The test methods of the class ==RawObjTest== that are in the categories =='step1-tests-structure of objects'== and =='step2-tests-structure of classes'== give some examples of structure accesses. Implement the primitives that are missing to run the following tests ==testPrimitiveStructureObjClassId==,
 ==testPrimitiveStructureObjIVs==, ==testPrimitiveStructureObjKeywords==, 
 ==testPrimitiveStructureObjMethodDict==, ==testPrimitiveStructureObjName==, ==testPrimitiveStructureObjIVs== and ==testPrimitiveStructureObjSuperclassId==. 

You can execute them by selecting the following expression ==(RawObjTest selector:
 #testPrimitiveStructureObjClassId) run==.  Note that arrays start at 1 in Pharo. Below is the list of the primitives that you should implement.

Implement in category =='object structure primitives'== the primitives that manage:
- the class of the instance represented  as a symbol. ==objClassId==, ==objClassId: aSymbol==. The receiver is an ==objObject==. This means that this primitive  can be applied on any objInstances to get its class identifier.

Implement in category =='class structure primitives'== the primitives that manage:
- the class name. ==objName==, ==objName: aSymbol==. The receiver is an objClass.
- the superclass ==objSuperclassId==, ==objSuperclassId: aSymbol==. The receiver is an objClass.
- the instance variables ==objIVs==, ==objIVs: anOrderedCollection==. The receiver is an objClass.
- the keyword list ==objKeywords==, ==objKeywords: anOrderedCollection==. The receiver is an objClass. 
- the method dictionary ==objMethodDict==, ==objMethodDict: anIdentityDictionary==. The receiver is an objClass.



!!!Finding the class of an object
Every object keeps the identifier of its class (its name). For example an instance of ==ObjPoint== has then the following structure: ==#(#ObjPoint 10 15)== where ==#ObjPoint== is a symbol identifying  the class ==ObjPoint==.
 
!!!! Your Job. 

Implement the following primitives:

- Using the primitive ==giveClassNamed: aSymbol== defined at the class level of Obj, define the primitive  ==objClass== in the category =='object-structure primitive'== that returns the objInstance that represents its class (Classes are objects too in ObjVLisp).

Make sure that you execute the test method: ==testClassAccess==

- In the category =='iv management'== define a method called ==offsetFromClassOfInstanceVariable: aSymbol== that returns the offset of the instance variable represented by the symbol. It returns 0 if the variable is not defined. Look at the tests ==#testIVOffset==. (Hints: Use the Pharo method ==indexOf:==).

Make sure that you execute the test method: ==testIVOffset==

Using the preceding method, define in the category =='iv management'== 
# the method ==offsetFromObjectOfInstanceVariable: aSymbol== that returns the offset of the instance variable and 
# the method ==valueOfInstanceVariable: aSymbol== that returns the value of this instance variable in the given object. Look at the tests ==#testIVOffsetAndValue==.  

Note that for the method ==offsetFromObjectOfInstanceVariable:== you can check that the instance variable exists in the class of the object and else raise an error using the Pharo method ==error:==.

Make sure that you execute the test method: ==testIVOffsetAndValue==


























