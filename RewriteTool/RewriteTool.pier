!The Rewrite Tool

'''""TODO:"" do a full pass on this chapter, fill in where indicated; layout figures/sections; 
change option naming (as list, recurse into etc.);'''

!!Introduction

The purpose of this chapter is to explain what is The Rewrite Tool, why do we need
it and how to use it properly. In this chapter we also explain how The Rewrite
Tool works. Inasmuch our tool uses The Rewrite Engine we describe its general concepts. 
With this engine we are able to create expressions which can be used to match and transform code. 
Often we encounter a situation when we want to transform some part of code in many different places 
to improve its quality and readability. Also code transformations are performed in order to change an API. 
Let us look at simple example of code transformation. 

[[[caption=Simple transformation|label=scr:simpleTransformation
	"Source code"
	self isNil ifTrue: [ ^ true ] 

	"Resulting code"
	self ifNil: [ ^ true ]
]]]

Consider that we want to transform all code, that has same structure as source code, 
within few specific packages, into a code, that would have the same structure as a resulting code in example. 
To carry out this code transformation manually on a big system, i.e. with large code base, 
one would have to spend a lot of time. Also manual code transformation is an error-prone and complex process, 
inasmuch one can easily miss a code, that matches source code structure. The last, but not the least problem 
of manual code transformation is following: if one transforms code (consider transformation from example) by hand 
and after some time wants to do same or similar transformation on other packages, he has to redo all the work. 
This means, that transformation implemented previously is not saved, thus it is not reusable.
However, you can use The Rewrite Engine to transform all of code in the way you want, if only you know how. 
The syntax of DSL (domain specific language) of The Rewrite Engine is not very straightforward and sometimes even confusing, 
that is why it may be a problem to create specific rules to match and transform code. 
Moreover, even if you know engine syntax perfectly, it is very easy to make a simple but important mistake, 
for instance, miss a dot or misspell some part of rewrite expression. Such a mistake may have a huge impact 
on the result of code transformation, however you will not be notified by system about an error. 

As you may have guessed, The Rewrite Tool helps to solve such a problems. 
It provides an intuitive GUI (graphical user interface) which allows user to create rewrite rules 
without knowledge of specific syntax, that is used in DSL of The Rewrite Engine. Moreover, after rule is created 
the tool ebables user to apply it to desired environment scope: packages, classes, methods. 
In addition, The Rewrite Tool saves all the rules in your image. This allows you to reuse transformation rules 
in future for same or similar code transformations. 
Also, you are able to modify rules later, as they are stored as classes.

In this chapter, we describe the tool itself in general. Then, we will take a look at examples that will show 
you The Rewrite Tool in work. After that, we will go in more details about tool and how it works.

!! Getting started

To begin, you need to load The Rewrite Tool into your image. In order to do this, 
execute one of the following scripts.

[[[caption=How to load The Rewrite Tool|label=scr:gettingStarted
	"Stable version for Pharo 4"
	Metacello new 
		smalltalkhubUser: 'Pharo' project: 'MetaRepoForPharo40';
		configuration: 'RewriteTool';
		load

	"Development version for Pharo 5"
	Metacello new 
		smalltalkhubUser: 'MarkRizun' project: 'RewriteTool';
		configuration: 'RewriteTool';
		version: #development;
		load
]]]

An alternative way to retrieve and load The Rewrite Tool is to use the Configuration Browser in Pharo 4 
(Catalog Browser in Pharo 5). Just type in the search pane "RewriteTool" (without quotes) 
like on the figure *@fig:configurationBrowser* and install stable version of the project.

+Configuration Browser in Pharo 4>file://figures/configurationBrowser.png|label=fig:configurationBrowser+

@sec:rewriteRuleBuilder
!!Rewrite rule builder

As soon as you have loaded The Rewrite Tool into your image, two new options appear under the "Tools" tab in world menu. 
First one is rewrite rule builder - a part of The Rewrite Tool which provides an intuitive GUI 
to create transformation rules dynamically, with immediate feedback. 
The second option opens rewrite rule browser which we discuss in the section *@sec:rewriteRuleBuilder*.
If you do not like to use world menu to open builder, you can always open it by executing following code: 

[[[caption=Open the builder|label=scr:builderOpen
	RewriteRuleBuilder new openWithSpec
]]]

As illustrated in figure *@fig:rewriteRuleBuilder*, builder has four panes.

+Rewrite rule builder>file://figures/rewriteRuleBuilder.png|label=fig:rewriteRuleBuilder+

Bottom half of the builder entitled "Transformation rule" is your main workspace - here you create transformation rule. 
The transformation rule consists of two parts - LHS (left-hand side) part of the rule and 
RHS (right-hand side) part of the rule. LHS part is used to match source code 
which is displayed in top left pane with label "Input". Green arrow indicates that LHS part of the rule matches source code. 
If the arrow becomes red it means, that LHS part of the transformation rule does not match source code. 
In case arrow is green, i.e. the rule matches source code, transformation rule is automatically applied to source code. 
The resulting code of this transformation is displayed in the top right panel with label "Output". 
You should note, that this pane is the only one that is read only, meaning it is not editable.
Transformation rule can be created two ways:
- via action-click contextual menu;
- directly typing the code of rule.

We strongly recommend to use ''only'' first option, as it is much more reliable and easier. 
When some item is selected in LHS part of rule contextual menu will provide appropriate list of options. 
For instance, if you select a block ([ ^ true ]), the the tool will propose an option "Abstract block". 
This option creates an abstraction (`@block1) which matches any instance of block. 

@sec:rewriteRuleBuilder
!!Rewrite rule browser

Rewrite rule browser is the second part of The Rewrite Tool. It provides an access to all transformation rules, 
that are present in your image. You can select one of them and apply it to any environment scope you want. 
The browser can be launched via world menu from "Tools" tab, or by executing following code:

[[[caption=Open the browser|label=scr:browserOpen
	RewriteRuleBrowser new openWithSpec
]]]

The browser is shown on figure *@fig:rewriteRuleBrowser*. All rules are available in drop down list at bottom of the window. 
Above you can see all packages, classes and methods, that are present in the image. 
After you clicked an "Apply rule:" button, a confirmation window will be opened. 
It shows changes which are going to be made, so you can conveniently preview them. 

+Rewrite rule browser>file://figures/rewriteRuleBrowser.png|label=fig:rewriteRuleBrowser+

!!Examples

In this part you can find useful examples, that will help you to understand how to use The Rewrite Tool. 
In particular, we describe how to create transformation rule with builder and apply it using browser. 

!!!First example

Consider, that we want to do a transformation described in following listing. 
Basically, here we replace isNil ifTrue: [ ] construction with ifNil: [ ] message send. 

[[[caption=First example of transformation|label=scr:firstExmple
	"Source code"
	self isNil ifTrue: [ ^ true ] 

	"Resulting code"
	self ifNil: [ ^ true ]
]]]

!!!!Step 1

First, you need to open a builder and input a source code into two panes: top left and bottom left. 
Now you have a LHS part of rule, that matches an input code (green arrow indicates this). 
After that, input the resulting code into bottom right pane. 
As a result you will see the same code in the top right pane.
Be sure to save any changes which you make in any pane in order to update the resulting code.

To start with, look at status arrow. Obviously, for now it says "matches", as source code and match rule are equal.
This status arrow will help you to create rule, that will really correspond to source code.
If it changes to "does not match", you probably should use "Undo" button, and rethink your next step.
As was mentioned earlier, your main playground is bottom half of builder, and in particular LHS part of rule. 
Thus, almost all next actions are made in the bottom left pane.
In our example we want to transform the structure of the code, 
however we do not care about receiver (''self'') or argument (''[ ^ true ]''). 
The receiver can be ''self'' or maybe just some temporary variable ''myVar'', 
or even some message send like ''Color red''. The argument has to be a block, but we are not interested in its contents. 
That is why we want to replace the receiver with some kind of abstraction which will match any object. 
Also we want to have an abstraction, that matches any block, instead of argument. 
In order to do that, you have to select receiver and action-click on it.

+Step 1 of first example>file://figures/example1-1.png|label=example1-1+

As shown in figure *@example1-1*, it displays all actions that can be
applied to selected object. In builder each object has its own set of options. 
In this particular case we see following options:
- Change / Rename
- Abstract object 

In this case we need to select ''Abstract object'', inasmuch it changes ''self'' into an abstraction, 
that matches any object. This abstraction is called a metavariable and as you can see in figure *@example1-2* 
the tool replaced receiver with a ''``@variable1''. 

+After step 1 of first example>file://figures/example1-2.png|label=example1-2+

You can read more about metavariables and The Rewrite Engine in the section ""section reference"".

Status arrow has to be unchanged, saying: ''matches''.
As you may noticed RHS part of rule was automatically changed - the receiver was replaced with same abstraction. 
It means that in result of the transformation the receiver (''self'') will not be changed.

!!!!Step 2

Now let us work with our block: ''[ ^ true ]''. We have the same situation as
we had with the receiver. Once again, we are not interested about contents of block, that is passed as
an argument to ''ifTrue:'' or ''ifNil:''. However it is important to make sure the the argument is actually a block. 
Therefore in LHS part of transformation rule select the argument (''[ ^ true ]'' - be sure to include the brackets) 
and choose the option ''Abstract block''. 
In the result of this action the argument will be replaced with new metavariable 
(''`@block1'') as shown in figure *@example1-3*.

+Step 2 of simple example>file://figures/example1-3.png|label=example1-3+

You can see the result of applying rewrite rule to source code in Result pane.

[[[caption=Result of transformation|label=scr:firstResult
	self ifNil: [ ^ true ]
]]]

You can click on "Generate rule" button to automatically generate a class that will represent your new rule. 
Give an appropriate name for your rule, for instance "IsNilIfTrueToIfNil" and click "Ok" button. 
After click on "Browse rules" button to open the browser. 

In the bottom part of the browser you can see drop down list with all transformation rules, 
that are present in your image. Right next to this list, there is a tick which says "Only custom rules". 
Check it in order to see only those rules, that you have created, 
and select a newly created rule named "IsNilIfTrueToIfNil". 
Than select packages/classes on which you would like to perform a transformation and simply click "Apply rule:" button. 
As a result you will see a window, that contains all the changes, that are going to be made after transformation. 

!!!Second example

This time we are going to recreate one of rules that already exists in Critic
Browser. We choose the one called ''RBMinMaxRule''. This class has a method initialize
where all rules are initialized. There you can see that ''RBMinMaxRule'' has
many similar rules. Thus let us recreate only one of them. 
Suppose we have a snippet of code that compares two object and returns the greater one of them.

[[[caption=Second example - source code|label=scr:secondExampleSource
	| a b result |
	a := 5.
	b := 3.
	result := a > b
		ifTrue: [ a ]
		ifFalse: [ b ].
	^ result
]]]

This piece of code is not very well implemented, so we would rather transform it into a simpler and more 
readable snippet of code as illustrated in the following listing. 

[[[caption=Second example - resulting code|label=scr:secondExampleResult
	| a b result |
	a := 5.
	b := 3.
	result := a max: b.
	^ result
]]]

Essentially, we can simplify described transformation to more general case shown in listing *@scr:desiredTransformation*.

[[[caption=Desired transformation|label=scr:desiredTransformation
	"Source code"
	result := a > b
		ifTrue: [ a ]
		ifFalse: [ b ].
	
	"Resulting code"
	result := a max: b.
]]]

!!!!Step 1
First of all, launch the builder and type the source code from listing *@scr:desiredTransformation* 
into top and bottom left panes. Than enter the resulting code from listing *@scr:desiredTransformation* 
into the bottom right pane. 

+Step 1 of second example>file://figures/example2-1.png|label=example2-1+

!!!!Step 2:
Now select ''result'' variable in LHS part of the rule use an ''Abstract object'' action on it. 
Apply the same operation on ''a'' and ''b'' variables.
After this steps the builder has to look like in the figure *@example2-2*.

+Step 2 of second example>file://figures/example2-2.png|label=example2-2+

""Note:"" Metavariable indexes (number in the end of name) may be different if you did other changes before
trying this example.

Use ''Generate rule'' button to generate the class for this rule in order to use it in the Browser.

!!!Third example

In this section  we will examine another transformation rule, that is used in Critics Browser, ==RBAtIfAbsentRule==. 
This rule works with collections and blocks, so its implementation may be more complicated than 
implementation of rules in two previous examples. With this rule we can do following transformation:

[[[caption=Example of possible transformation with RBAtIfAbsentRule|label=scr:possibleTransformation
	"Source code"
	| myDictionary |
	myDictionary := Dictionary new 
		at: 1 put: 'a';
		at: 2 put: 'b';
		yourself.
	myDictionary at: 3 ifAbsent: [
		| temp1 temp2 temp3 | 
		temp1 := 'c'.
		temp2 := 'd'.
		temp3 := temp1, temp2.
		myDictionary at: 3 put: temp3 ].
	^ myDictionary

	"Resulting code"
	| myDictionary |
	myDictionary := Dictionary new
		at: 1 put: 'a';
		at: 2 put: 'b';
		yourself.
	myDictionary at: 3 ifAbsentPut: [ 
		| temp1 temp2 temp3 |
		temp1 := 'c'.
		temp2 := 'd'.
		temp3 := temp1 , temp2.
		temp3 ].
	^ myDictionary
]]]

This code contains all keywords that are present in rule such as: #at:ifAbsent:, and #at:ifAbsentPut:. 
Current example is using this code, to implement the ==RBAtIfAbsentRule== rule.

!!!!Step 1:

To begin with copy and paste source code from listing *@scr:possibleTransformation* in top and bottom left panes. 
After that copy resulting code from listing *@scr:possibleTransformation* in bottom right pane. 
Now we are ready to implement the rule.

+Step 1 of ifAbsent: transformation example>file://figures/example3-1.png|label=example3-1+

!!!!Step 2:
To start with, select any reference of ''myDictionary'' in LHS part of the rule, 
except one that is a variable declaration, and apply ''Abstract object'' option.

Now select literal object ''3'' - one of the keys, that we use in source code 
and bring up the contextual menu. 
Note, that here we have one additional option - ''Abstract literal''. 
If you select this option, the tool creates an abstraction which matches any literal, 
i.e. ''5'', '''myString''', ''#aSymbol'' etc. 
However, if you select the ''Abstract object'' option, the tool creates an abstraction 
which matches any objects. It may be a literal, temporary variable or even message send. 
Clearly, the ''Abstract object'' option creates more generic abstraction, 
thus we suggest to select this one. 

+Step 2 of ifAbsent: transformation example>file://figures/example3-2.png|label=example3-2+

!!!!Step 3:
Apply ''Abstract statement'' action to code provided in listing *@scr:statementToAbstract*.

[[[caption=Statement to abstract|label=scr:statementToAbstract
	"..."

	``@variable1 := Dictionary new
	at: 1 put: 'a';
	at: 2 put: 'b';
	yourself.

	"..."
]]]

Basically, it will match pretty much any statement, and as a result we have ''`@.Statement1''.
To finish with initialization part of this code, 
select declaration of temporary variable ''| myDictionary |'' and do on it ''Abstract temporaries list''.
Apply the same action on the temporaries list in RHS part of the rule. 
In opened window select ''| ``@temporaries1 |'' option.

!!!!Step 4:
After this steps, lets take a look at the argument of ''#ifAbsent:'' - a block. 
With temporaries declaration ''| temp1 temp2 temp3 |'' we do exactly the same thing as in previous step. 
Just apply the ''Abstract temporaries list'' option in both 
LHS and RHS parts of the transformation rule. However, now in opened window choose 
''| ``@temporaries2 |'' instead of ''| ``@temporaries1 |''. 

Apply the ''Abstract statement""s""'' action to next snippet of code presented 
in the listing *@scr:statementsToAbstract*. Repeat the same action in RHS part and choose ''`@.Statements2''. 

[[[caption=Statement""s"" to abstract|label=scr:statementsToAbstract
	"..."

	temp1 := 'c'.
	temp2 := 'd'.
	temp3 := temp1 , temp2.

	"..."
]]]

The rule is almost ready, there is one variable left that we have to change - ''temp3''. 
Select it and use ''Abstract object'', and that is how you get ''``@variable3''. 
Finally we have our rule, which does exactly what we wanted - 
transformation that is mentioned in the beginning of this example. 

+Step 4 of ifAbsent: transformation example>file://figures/example3-3.png|label=example3-3+

!!The Rewrite Tool in details

In this section we describe The Rewrite Tool in details: we explain how all features work, 
provide some tips to improve your effectivenes in work with The Rewrite Tool. 

@sec:menuOptions
!!!Menu options

List of all available options via contextual menu:
- Abstract object
- Abstract literal
- Abstract block
- Abstract statement
- Abstract statements
- Abstract condition
- Abstract temporaries list
- Change / Rename
- Undo on node

Any of abstract action replaces selected object(s) with metavariable - an abstraction to match nodes of AST. 
Note, that each metavariable name ends with an index, but it is not displayed in the examples below.

''""Abstract object""''

Matches any object, even if it is represented by message send (e.g. ''self'', ''Object'', ''123'', ''myVar foo'').

[[[caption=Metavariable, that is created by ''Abstract object'' action|label=scr:abstractObject
	``@object "or" ``@variable
	
	"matches"
	
	myObject
]]]

''""Abstract literal""''

Matches any literal object (e.g. ''1'', '''aString''', ''#aSymbol'').

[[[caption=Metavariable, that is created by ''Abstract literal'' action|label=scr:abstractLiteral
	`#literal

	"matches"

	true
]]]

''""Abstract block""''

Matches any block (e.g. ''[ ^ true]'', ''[ :each | each name ]''). 

[[[caption=Metavariable, that is created by ''Abstract block'' action|label=scr:abstractBlock
	`@block 

	"matches"

	[ :x :y | x + y ]
]]]

''""Abstract statement""''

Matches any single statement (e.g. ''self halt'', ''self foo bar'', ''self isNil ifTrue: [ ^ false ]'').

[[[caption=Metavariable, that is created by ''Abstract statement'' action|label=scr:abstractStatement
	`.@Statement
	
	"matches"

	myVar name = 'CoolVar'
		ifTrue: [ myVar := myVar + 1 ]
		ifFalse: [ myVar := myVar - 1 ]
]]]

''""Abstract statements""''

Matches any sequence of statements including zero and one statement 
(e.g. ''result := 1 + 2. ^ result'', ''self foo bar'', ''"nothing here but matches"'').

[[[caption=Metavariable, that is created by ''Abstract statements'' action|label=scr:abstractStatements
	``@.Statements
	
	"matches"

	myVar name = 'CoolVar'
		ifTrue: [ myVar := myVar + 1 ]
		ifFalse: [ myVar := myVar - 1 ].
	^ myVar * 2
]]]


''""Abstract condition""''

Matches any message send, that is as a condition 
(e.g. ''self size = 5 ifTrue: [ ^ self name ]'' - here the reciever of ''#ifTrue:'' message is a condition). 
Actually, the ''Abstract condition'' option creates exactly the same metavariable as the ''Abstract object'' option. 
But it is more convinient to have two separate options, and display each of them in corresponding situation. 
Message send is considered a condition if it is a receiver of such message as ''#ifTrue:'', ''#ifFalse:'', ''#ifNil:'' etc. 

[[[caption=Metavariable, that is created by ''Abstract condition'' action|label=scr:abstractCondition
	``@condition ifTrue: [ ^ true ]
	
	"matches"

	self isNil ifTrue: [ ^ true ]
]]]

''""Abstract temporaries list""''

Matches any list of temporary variables declaration (e.g. ''| a b result|'', | temp1 temp2 |). 

[[[caption=Metavariable, that is created by ''Abstract condition'' action|label=scr:abstractCondition
	| ``@temporaries |
	
	"matches"

	| myVar1 myVar2 |
]]]

''""Change / Rename""''

Replaces selected node of AST with users input. Better than simple manual change, inasmuch all occurences are modified in the different panes.


''""Undo on node""''

Sets selected node of AST in previous state.


[[[caption=Example of applying the ''Undo on node'' action|label=scr:undoOnNode
    self ''Abstract object'' => ``@variable
    ``@variable ''Undo on node'' => self
]]]

!!!Working with rewrite rules

This section provides useful tips about working in builder.
It will help you to understand the mechanics of building rule with The Rewrite Tool.

''""Equal nodes""''

First thing worth mentioning is that any action applied in LHS part of ruel,
also applies to all references of this object in both LHS and RHS parts of transformation rule.
If it is applied in RHS part, only objects in it are changed, but not in LHS part.

''""Non-existing metavariables""''

Another thing, that you shuld know is that you can not create new metavariable in RHS part of rule, 
if it is not created in LHS part. Meaning, that you are not able to apply, for example, ''Abstract block'' action in RHS part, 
if there is no metavariable in LHS part of the rule. 
If there is one, the tool will suggest you to choose name from existing metavariables. 
Let us consider example from listing *@scr:nonExistingMetavariables*.

[[[caption=Example of non existing metavariables|label=scr:nonExistingMetavariables
	"Source code"
	self children do: [ :each | each check ].
	self ifNotNil: [ self children last remove ].
	^ self size
    
	"Resulting code"
	self children do: [ :each | each check ].
	self ifNotNil: [ self children last remove ].
	^ super size
]]]

In case you select ''super'' in RHS part and apply ''Abstract object'' action, you will see the alert window, 
indicating, that there are no available metavariables for this action. 
But if you previously done this action in LHS part with ''self'' object, 
it is possible now to create metavariables in RHS part.
With other actions like ''Abstract literal'', ''Abstract condition'' etc. happens exactly the same thing.

''""Manual editing""''

One more important thing is that creating rewrite rules with manual editing, instead of action click menu options, is not recommended.
First of all, you will not have general ''Undo'' as well as ''Undo on node'' options available.
Moreover you may make mistake in The Rewrite Engine syntax. 
And also, it is possible to get errors from, for example, creating non-existing metavariables by hand. 
To sum up, rewrite rule builder allows you to edit rules, but do it only if really necessary. 

!!Architecture of The Rewrite Tool

This section covers the architecture of The Rewrite Tool, explains responsibilities of classes.
Also it gives a clear understanding of class hierarchy of The Rewrite Tool. 

!!!AbstractPanel

''AbstractPanel'' is an abstract class,
which represents a panel that contains text field.
Text field contains a code, which is considered later as an AST in order to make further manipulations with code possible.
Also in ''AbstractPanel'' class is implemented basic behavior of all actions,
that were described in *@sec:menuOptions*.
Why "basic behavior", you might ask?
That is so, because each of ''AbstractPanel'' subclasses shares this behavior, however its not complete in the abstract class.
Its subclasses represent four panels of builder and they are: ''SourcePanel'', ''MatchPanel'', ''TransformPanel'', ''ResultPanel'',
which were mentioned in *@sec:rewriteRuleBuilder*.
Moreover ''AbstractPanel'' class implements update methods, that, update different information such as an AST, 
text, current metavariables names etc. 

Methods of ''AbstractPanel'':

1. ""==#parse:=="" parses a string as rewrite expression. 

2. ""==#executeCommand:withSource:=="" is used to execute any command, class of which is passed as an argument.
This particular command is executed for each node that is equal to currently selected node.
Also, this method adds changes to undo dictionary, that holds all previous changes that were made.
After command is executed, update methods are invoked.

3. ""==#updateAst=="" updates AST of current panel.

4. ""==#updateText=="" updates text (code) of current panel, that is displayed.

5. ""==#updateInfoFor:withOld:andNew:=="" updates text and ast of panel. 
Also updates ''oldNodes'' property of all nodes in AST.
Invokes method, which responsibility is to update next panel. 
Next panel is Transform Panel for Match Panel, and Result Panel for Transform Panel. 

6. ""==#getAllMetavariables=="" returns a collection of all metavariables that are used in current panel.

7. ""==#difference:with:=="" returns a mathematical difference of sets, however works not with sets but with collections, 
so duplicates are possible. 

8. ""==#isSelectedAll=="" returns ''true'' if all code in current panel is selected. 

9. ""==#manageUndoDictFor:=="" adds an instance of RewriteRuleChange class to ''undoDict'' instance variable, 
which holds all changes for ''Undo'' action. 
This variable is discussed later. Also this method enables ''undoButton''. 
Next, we examine subclasses of ''AbstractPanel''.

!!!SourcePanel

Instance of this class holds source code of expression, that can be transformed.
Actually, ''SourcePanel'' implements only one new feature that is not inherited from ''AbstractPanel''.
By action-clicking in source panel user is able to rename any variable. 
This feature is handy in case you have many references of one variable and want to rename this variable.

!!!ResultPanel

Presents disabled text field, which means that user can not edit text contained in this panel. 
''ResultPanel'' holds result of applying transformation rule to source code.

[[[
	initialize
		super initialize.
		self templateText disable
]]]

!!!MatchPanel

Instance of ''MatchPanel'' holds matching part of rewrite rule (i.e. LHS part of transformation rule). 
To begin with, this class controls all indexes that are added after each metavariable name. 
When user makes any action, that creates new metavariable in rule, ''MatchPanel'' adds index at the end of metavariable name. 
Than index of coresponding metavariable group is incremented. 
For example, ''MatchPanel >> #abstractBlock''

[[[
	abstractBlock
		"first the action is executed, thus new metavariable is created"
		super abstractBlock.
		"than index is incremented by one"
		self blockIndex: self blockIndex + 1
]]]

All other actions are implemented in similar way. 
Also ''MatchPanel'' has an instance variable ''varNames'' which represents a collection of all metavariables, 
that are currently present in transformation rule. 
This variable helps to ensure, that RHS part of rule uses only already existing metavariables. 
As use of non existing metavariables in right hand side part of rule would lead to an error. 
More information about usage of ''varNames'' instance variable is given in next section about ''TransformPanel'' class. 

Methods of ''MatchPanel'':

1. ""==#addChanges=="" any action, that changes AST of instance of ''MatchPanel'' class, 
is recorded into instance variable ''undoDict'' of instance of ''TransformationRule'' class. 
Generally, ''undoDict'' is a collection of all changes made within ''MatchPanel'' and/or ''TransformPanel''. 

2. ""==#updateVarNames=="" updates ''varNames'' instance variable, so it holds only existing metavariables from ''MatchPanel''. 

3. ""==#updateTransformPanelFor:=="" does a pass on AST, that is held by ''TransformPanel''. 
Replaces nodes in ''TransformPanel'', that are equal to node which was just changed in ''MatchPanel''.
Than the displayed text and AST of ''TransformPanel'' are updated. 

4. ""==#updateNextPanelForNode:=="" is invoked after the current panel is updated in method ''#updateInfoFor:withOld:andNew:''. 
First of all, this method updates ''varNames'' instance variable. 
After this, ''TransformPanel'' itself is updated via ''#updateTransformPanelFor:'' method. 
Than, ''statusBar'' color and information text are updated. 
''statusBar'' instance variable is explained later. 
In the end, ==#updateNextPanelForNode:== is invoked for ''TransformPanel'', so the ''ResultPanel'' is updated as well. 

!!!TransformPanel

''TransformPanel'' class is a subclass of ''AbstractPanel'', instance of which holds RHS part of transformation rule. 

Methods of ''TransformPanel'':

1. ""==#addOldNodes:=="" updating information about ''oldNodes'' for each node in AST of ''TransformPanel''. 
''oldNodes'' propery of AST holds all nodes, that where replaced up to the current node. 

2. ""==#chooseMetavariablesForNode:=="" when user applies action such as ''Abstract object'' in ''TransformPanel'' window is opened. 
In this window user can choose one of available metavariables to replace current node with it. 

3. ""==#chooseTempsForNode:=="" same as ''#chooseMetavariablesForNode:'', but is used when ''Abstract temporaries list'' action is invoked. 

4. ""==#updateNextPanelForNode:=="" applies rewrite rule from ''MatchPanel'' and ''TransformPanel'' to AST of ''SourcePanel''. 
As result we have new AST. Code of this AST is displayed in ''ResultPanel''.

!!!TransformationRule

''TransformationRule'' is a model that represents bottom part of builder. 
It contains ''MatchPanel'', ''TransformPanel'' and all buttons (undo, redo, generate rule, browse rules). 
Plus it has ''undoDict'' and ''redoDict'' instance variables. 
This variables are collections of instances of ''RewriteRuleChange''. 
Each change, that is made in one of three editable panes of builder is recorded in ''undoDict''. 
Obviously, ''undoDict'' instance variable is used in implementation of ''#undo'' action. 
When undoing a change, it is removed from ''undoDict'' and added to ''redoDict'', which is used for implementation of ''#redo'' action. 

Methods of ''TransformationRule'':

1. ""==#addChangeForPanel:=="" adds a change to ''undoDict''. 
Change is initialized with panel, passed to this method, and its AST. 

2. ""==#browseRules=="" opens up browser. 

3. ""==#generateRewriteRuleClass=="" generates new subclass of RBTransformationRule. 
This class is stored in a ''RewriteRulesCustom'' category. 
The generated class has only one method - ''#initialize''. 
Code of this method is generated by ''#getRuleInitString'' method, which is explained next. 
The name of class is specified by user, initially it is ''MyRule''. 

4. ""==#getRuleInitString=="" forms and returns a string, that is a code of ''#initialize'' method of ''RBTransformationRule'' subclass. 

5. ""==#matchPanelChanged=="" is invoked when text in ''MatchPanel'' is accepted. 
First of all, it adds change made in ''MatchPanel'' to ''undoDict'' and enables ''undoButton''. 
Also it updates AST and text of ''MathcPanel''. 
Than it updates information related to ''statusBar'' - color and text. 
''statusBar'' is an instance variable of ''RewriteRuleBuilder''. It indicates if LHS part of rule matches source code. 
In the end, the ''ResultPanel'' info is updated. 

6. ""==#transformPanelChanged=="" is similar to ''#matchPanelChanged'' method, but does not update information about ''statusBar''. 
It is invoked when text in ''TransformPanel'' is accepted. 
First of all, it adds change made in ''TransformPanel'' to ''undoDict'' and enables ''undoButton'' if it is still disabled. 
Also it updates AST and displayed text of ''TransformPanel''. 
In the end, the ''ResultPanel'' info is updated. 

7. ""==#undo=="" reverts last change, that was made in either ''SourcePanel'', ''MatchPanel'' or ''TransformPanel''. 
Removes this change from ''undoDict''. Also it adds just undone change to ''redoDict''. 
Next it updates displayed text and AST for each panel where changes were reverted. 
Finally the ''#updateAfterUndoOrRedo'' method is invoked. 

8. ""==#redo=="" does undone change again to each panel influenced by ''#undo''. 
Also it adds just redone change to ''undoDict''. 
Next it updates displayed text and AST for each panel where changes were reverted. 
Finally the ''#updateAfterUndoOrRedo'' method is invoked. 

""Note:"" as we see from two previous methods, that ''#undo'' and ''#redo'' can be done infinit number of times. 

9. ""==#ruleLabel==""  is an instance of ''StringMorph'', that is displayed above ''MatchPanel'' and ''TransformPanel''.  

10. ""==#statusBarForRule=="" returns an arrow that is placed between ''MatchPanel'' and ''TransformPanel''. 

11. ""==#updateAfterUndoOrRedo=="" enables or disables undo and redo buttons. 
Also updates text and color for ''statusBar'' instance variable of ''RewriteRuleBuilder''. 
In the end, ''ResultPanel'' code is updated. 

12. ""==updateUndoDictFor:=="" adds a change to ''undoDict''. 

13. ""==updateRedoDictFor:=="" adds a change to ''redoDict''. 

Methods of ''TransformationRule class'':

14. ""==#arrowMorph:=="" is an instance of ''PolygonMorph'' or ''ActivePolygonMorph''. 
It is shaped in form of arrow. 

15. ""==#defaultSpec=="" creates a layout for all components. 

!!!RRTextModel

''RRTextModel'' is a subclass of TextModel. It has some features which are needed for builder, as support of AST and custom menu. 
Instances of ''RRTextModel'' are used in each of four panes: ''SourcePanel'', ''MatchPanel'', ''TransformPanel'' and ''ResultPanel''. 
Each pane stores instance of this class in ''textModel'' instance variable. 
''textModel'' stores AST and gives acces to custom menu, which can be invoked by right click inside of the pane. 

Methods of ''RRTextModel'':

1. ""==#actionsForSelection=="" performs ''#menuOptions'' for panel that is storet in ''model'' instance variable. 
''#menuOptionsSelector'' fills right click menu with all available actions for selected node. 

2. ""==#getSelectedNode=="" returns node, which is currently selected in ''textModel''. 

3. ""==#codePaneMenu:shifted:=="" forms a menu due to ''#actionsForSelection'' method. 

!!!RewriteRuleChange

''RewriteRuleChange'' is class that holds changes which were made in builder panes. 
Instances of this class are stored in collection ''undoDict'' - the instance variable of ''TransformationRule''. 
The implementation of this class is very simple: it has only two instance variables - ''panel'' and ''ast''. 
''panel'' is one of four panes of builder, and ''ast'' is an AST of this panel. 

!!!ActivePolygonMorph

''ActivePolygonMorph'' is a subclass of ''PolygonMorph''. 
It recognizes two events - ''#mouseEnter:'' and ''#mouseLeave:''. 
Also it has ''infoText'' instance variable, which contains text information,
 that says if AST of ''SourcePanel'' matches LHS part of the transformation rule (AST of ''MatchPanel''). 

Methods of ''ActivePolygonMorph'':

1. ""==#infoMorph=="" constructs morph, which is a ''BorderedMorph'' with ''StringMorph'' submorph. 
Contents of ''StringMorph'' is assigned to ''infoText'' instance variable, that is described before. 

2. ""==#mouseEnter:=="" adds to self a submorph, that was created in ''#infoMorph'' method. 

3. ""==#mouseLeave:=="" removes from self a submorph, that was created in ''#infoMorph'' method. 

4. ""==#handlesMouseOver:=="" states that ''ActivePolygonMorph'' handles mouse over events, i.e. returns ''true''. 

!!!RewriteRuleBuilder

Instance of ''RewriteRuleBuilder'' class is a builder. 
''RewriteRuleBuilder'' contains instances of ''SourcePanel'', ''ResultPanel'' 
and the most important part of builder - instance of ''TransformationRule''. 
This class is responsible for graphical user interface and layout of all elements in builder. 
Also it holds labels, that are displayed in builder. 

''statusBar'' instance variable is an ''ActivePolygonMorph'', that shows if AST of ''SourcePanel'' matches AST of ''MatchPanel''. 
Firstly, its color is green (matches) or red (does not match).
This color is returned by ''#matchColor'' method. 
Secondly, when mouse is over it, the ''StringMorph'' shows up with text from ''#matchLabel''. 

Methods of ''RewriteRuleBuilder'':

1. ""==#matchLabel=="" returns a string that says if AST of ''SourcePanel'' matches AST of ''MatchPanel'' or not. 

2. ""==#resultLabel=="" returns an information string for indicating a ''ResultPanel''. 

3. ""==#rules=="" is a collection of all subclasses of ''RBTransformationRule'' class. 

4. ""==#matchColor=="" returns green or red color for ''statusBar''. 

5. ""==#sourcePanelChanged=="" is invoked when text is accepted in ''SourcePanel''. 
It adds a change, that was made and accepted to ''undoDict'' and enables undo button. 
Also updates displayed text and AST of ''SourcePanel''. 
After that, it assigns right color and text to ''statusBar'' properies. 
Finally, this method updates code of ''ResultPanel''. 

6. ""==#code:=="" assigns a string to ''code'' instance variable of each pane in builder. 

7. ""==#statusBarForMatch=="" is a method used to initialize ''statusBar'' instance variable. 
Basically, it returns an instance of ''ActivePolygonMorph'' ''#asSpecAdapter''. 

8. ""==#statusBarForResult=="" returns an instance of ''ActivePolygonMorph'' ''#asSpecAdapter''. 
This morph is used to indicate ''ResultPanel''. 
When mouse is over, shows a label with ''#resultLabel'' text. 

9. ""==#isMatching=="" returns a boolean, that is ''true'' when AST of ''SourcePanel'' matches AST of ''MatchPanel'', and ''false'' when it does not match. 

Methods of ''RewriteRuleBuilder class'':

10. ""==#withCode:=="" creates an instance of ''RewriteRuleBuilder''. 
Each panel ''code'' is initiialized with a string, that is passed as an argument. 

11. ""==#defaultSpec=="" creates a layout for all components. 

12. ""==#menuCommandOn:=="" adds builder to a world menu under ''Tools'' tab. 

13. ""==#shiftedSourceCodeMenu:=="" adds builder to a Nautilus context menu under ''Source code refactoring'' tab. 
Each panel ''code'' instance variable in builder is initialized with selected code in Nautilus. 

!!!Command

''Command'' (abstract class) and its subclasses are implemented similar to Command pattern. 
However, there are differences between this implementation and conventional one. 
''Command'' class has instance variable ''commandReceiver'' which is a reciever of action that should be performed. 
''commandReceiver'' is a node of AST. 
Another important element of ''Command'' class is ''#execute'' method. 
It is a generic method that is hard-coded for each subclass of ''Command'' class. 
Therefore for each action in Command pattern there is implemented one specific subclass of ''Command'' class with its own ''#execute'' method. 
''panel'' instance variable presents ''MatchPanel'' or ''TransformPanel''. 
The ''panel'' is the owner of the ''commandReceiver''. 

Methods of ''Command'': 

1. ""==#execute=="" is responsible for executing an action. 
Each subclass must implement this method. 

2. ""==#change:For:=="" replaces first argument for second. Both arguments are nodes of AST. 
So for replacement this method uses either assignement or ''#replaceWith:'' method, that is implemented in the ''RBProgramNode'' class. 

3. ""==#changeCommandReceiverFor:=="" uses ''#change:For:'' method with a first argument equal to ''commandReceiver''. 

Methods of ''Command class'': 

4. ""==#receiver:panel:index:withSource:=="" creates new instance of ''Command'' class initialized using arguments. 

5. ""==#isAccepted:=="" returns ''true'', explained in subclasses. 

6. ""==#isSequenceNeeded=="" returns ''false'', explained in subclasses. 

!!!AbstractCommand

''AbstractCommand'' class implements common functionality for actions (commands) which, 
in result, create new metavariable (abstraction for an object). 

Methods of ''AbstractCommand'': 

1. ""==#abstractName=="" is a name of metavariable, that may be created with specific command. 
Each subclass must implement this method. 

2. ""==#length=="" returns length of metavariable name, that may be created with specific command. 

3. ""==#abstractWithName:andIndex:=="" creates metavariable named ''#abstractName''. 
Than replaces ''commandReceiver'' with this metavariable.

Each subclass of this class implements ''#execute'' method almost identically to each other. 

[[[
	execute
		^ self abstractWithName: self abstractName andIndex: self panel
]]]

Basically, it invokes ''#abstractWithName:andIndex:'' method, and as arguments passes: 
1) its ''#abstractName'';
2) index of specific metavariable type (it may be block, variable, statement, etc.)

You can see which metavariable is created in ''#abstractName'' method. 
For example, ''AbstractBlockCommand'' creates ''`@block'' metavariable. 
Thus, The Rewrite Engine will match any block.
