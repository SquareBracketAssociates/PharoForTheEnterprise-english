!Rewrite Tool

The purpose of this chapter is to explain what is Rewrite Tool, why do we need it and how to use it properly.
Also, to understand better how Rewrite Tool works. Inasmuch it uses rewrite engine, its general concepts are described.
This engine, which is really powerful and very useful, is used by Pharo to match and transform expressions or methods.
Often we encounter a situation when we want to transform some part of code in a lot of different places into another code.
For example, if you want to change 

[[[ label = matchExample | language = Smalltalk
    someObject isNil ifTrue: [ ^ true ] 
]]]
to next code:
[[[ label = transformExample | language = Smalltalk
    someObject ifNil: [ ^ true ]
]]]
in each and every method of your package.
It may take a lot of time and nerves to manage this manually.
However, you can use rewrite engine to transform all of your methods in the way you want, if only you know how.
The syntax of rewrite engine is not that straightforward, thus to create specific matching and transforming rules with it you will have to spend some time.
Moreover, even if you know engines syntax perfectly, it's very easy to miss a dot somewhere or misspell some part of rewrite expression.
As you may have guessed, Rewrite Tool helps us to solve such a problem.
It provides a GUI which allows user to create rewrite rules without knowledge of rewrite engine syntax.
After rule is created you may simply apply it to scope that you want: packages, classes, methods.

In this chapter, first of all, the tool itself is described in general.
Then, we will take a look at example that will show you Rewrite Tool in work.
After that, we will go in more details about tool and how it works.

!! Getting started

[[[
MCHttpRepository
	location: 'http://smalltalkhub.com/mc/MarkRizun/RewriteTool/main'
	user: ''
	password: ''
	
()
]]]

[[[
Gofer new
  url: 'http://smalltalkhub.com/mc/MarkRizun/RewriteTool/main';
  package: 'ConfigurationOfRewriteTool';
  load.
(Smalltalk at: #ConfigurationOfRewriteTool) loadDevelopment
]]]

better

[[[
Gofer new
  url: 'http://smalltalkhub.com/mc/MarkRizun/RewriteTool/main';
  configuration;
  load.
ConfigurationOfRewriteTool loadDevelopment
]]]


!!Introduction

Rewrite Tool includes two parts. First is a rewrite rule builder (just ''"builder"''), which, obviously, lets user create rewrite rules.
And second part is rewrite rule browser(next as ''"browser"''), in which user can select previously created rule and apply it to specific scope.

!!!Rewrite rule builder

Builder has four panes and three buttons, and each of this items has its own functions.
It provides a possibility, with simple GUI, to build rewrite rules dynamically.

+Rewrite rule builder>file://figures/rewriteRuleBuilder.png|label=Rewrite rule builder+

""Panes""

-Top left pane, labeled ''"Source expression"'', contains source code of expression (in future maybe method?) which will be matched and then transformed. It means, that you should input in this pane whatever you want to transform into something else.
-Bottom left pane with label ''"Match rule"'', is your playground. Here you will create matching part of rewrite rule. You can change match rule either using action-click menu or manually changing the code.
-Bottom right pane is pretty much the same as previous one. Here you have label ''"Transform rule"''. It's a second part of rewrite rule. In this pane you can create transform rule also with options in action-click menu, or just manually typing code.
-The last one, but not the least important, is top right pane - ''"Result expression"''. It displays the result of applying a rewrite rule, which is in two bottom panes, to a source expression. You should note that this pane is the only one that is not editable.

""Buttons""

-"Undo" is a general undo. It performs an undo action for three editable panes: Source, Match and Transform. Also there are is local undo for each pane separately (DESCRIBED LATER).
-"Generate rule" button creates new class - a subclass of ''RBTransformationRule'' using information from two bottom panes. After the rule is created using this button, you can apply it to specific scope.
-"Browse rules" button opens up "Rewrite rule browser", which allows you to browse created rules, and apply them to scope that you want.

!!!Rewrite rule browser

This tool contains all previously created rewrite rules in most left pane. Also it displays all packages / classes / protocols / methods that are present in the current image.

You can select a rewrite rule that you want to apply. Then choose a scope, which you want to be transformed with this rule and click "Apply rule to selected scope" button.
In order to browse slected rewrite rule class, click "Browse selected rule" button.

+Rewrite rule browser>file://figures/rewriteRuleBrowser.png|label=Rewrite rule browser+

!!Simple example

Now, back to example: we want to transform

[[[ label = matchExample | language = Smalltalk
    someObject isNil ifTrue: [ ^ true ] 
]]]

into:

[[[ label = transformExample | language = Smalltalk
    someObject ifNil: [ ^ true ]
]]]

First, you need to input template source code in top left pane of rewrite rule builder. ''(how to input? - "IN DEVELOPEMENT!")''
In all panes you get exactly the same code.
To start with, look at status bar in bottom left pane. Obviously, for now it says "matches", as source code and match rule are equal.
This status bar will help you to create rule, that will really correspond to source code.
If it changes to "doesn't match", you probably should use "Undo" button, and rethink your next move.
As was mentioned earlier, your main playground is bottom left pane.
Thus, almost all next actions are made in ''"Match rule"'' pane.
In our example we don't care about ''someObject''.
It can be ''self'' or maybe just some temporary variable.
That is why, you have to select ''someObject'' and right click on it, which opens a menu,
which displays all actions that can be applied to selected object.
Actually this object is represented as a node of an AST - abstract syntax tree.
In ''"Rewrite tool"'' each node of AST has its own set of options.
Read more on abstract syntax tree ''""HERE""''. 
In this particular case it will contain following options:
- Ignore
- Change
- Abstract variable 
You need ''"Abstract variable"'', inasmuch it changes ''someObject'' into metavariable.
This metavariable will match any object for example: ''self'', ''Color'' (classes are objects too), ''someTempVar''.
After this change we should have:

[[[ label = matchExampleStep1 | language = Smalltalk
    `variable1 isNil ifTrue: [ ^ true ] 
]]]

And status bar also has to be unchanged, saying: ''matches''.
As you may noticed ''"Transform rule"'' pane text also was changed in following way:

[[[ label = transformExampleStep1 | language = Smalltalk
    `variable1 ifNil: [ ^ true ]
]]]

It means that in result on the place of ''someObject'' we will get ''someObject''.
In case, you want to have in result something else, for example ''self'' use an option ''Change'' (or manually type it, but it's not recommended).
But for now, we don't want that.
To proceed, select ''isNil'' in ''"Transform rule"'' pane, open a menu.
The options in this case are different from previous one, as it's not a variable selected, but selector.
So, click on ''Ignore selector'' option. It will remove ''isNil'' from ''"Transform rule"'' pane.
Also, ''"Result expression"'' pane was updated:

[[[ label = resultExampleStep1 | language = Smalltalk
    someObject ifTrue: [ ^ true ]
]]]

Now let's work with our block: ''[ ^ true ]''.
Here we have the same situation as we had with ''someObject''.
Again, we don't care about which block is passed as an argument to ''ifTrue:'' or ''ifNil:''.
So, we select our block (now working in ''"Match rule"'' pane) and choose an option ''Abstract block''.
In result it will be changed into ''`@block1''.

Finally, select ''ifTrue:'' in ''"Transform rule"'' pane, and apply ''Change selector'' option from menu.
Type in recently opened window: ''ifNil:'', and press ''Ok'' button.
We are done with our task.
You can see the result of applying rewrite rule to source code in top right pane.

[[[ label = resultExampleStep2 | language = Smalltalk
    someObject ifNil: [ ^ true ]
]]]

!!Rewrite Tool in details

In this section each and every part of rewrite tool is described in details.
There are explained a lot of important ideas.
Understanding of this ideas is crucial, because it will increase users effectivity, while working with tool.

+Simple example>file://figures/simpleExample.png|label=Simple example+

!!!Menu options

List of all available options (may be changed):
- Abstract block
- Abstract condition
- Abstract literal
- Abstract statement
- Abstract variable
- As list
- Recurse into
- Change
- Change selector
- Ignore
- Ignore selector
- Undo on node

!!!!""Abstract actions""

Any of abstract action replaces selected object(s) with metavariable that corresponds to selected node of AST.

Next is described what can be matched with the metavariable in each case.

Note: In the end of each metavariable name there is an index, but it is not displayed in the examples below.

''""Abstract block""''

Matches any block.

[[[ label = blockExample | language = Smalltalk
    [ "a lot of stuff here" ] "replaced with" `@block
]]]


''""Abstract condition""''

Matches any condition.

[[[ label = conditionExample | language = Smalltalk
    self isNil ifTrue: [ ^ true ] "is replaced with" `@condition ifTrue: [ ^ true ]
]]]

''""Abstract literal""''

Matches any literal.

[[[ label = literalExample | language = Smalltalk
    true "is replaced with" `#literal
    119 "is replaced with" `#literal
]]]

''""Abstract statement""''

Matches any statement, but not list of statements.

[[[ label = statementExample | language = Smalltalk
    self isNil ifTrue: [ ^ true ] "is replaced with" `.Statement
]]]

''""Abstract variable""''

Matches any variable.

[[[ label = variableExample | language = Smalltalk
    self "is replaced with" `variable
]]]

!!!!""Other actions""

''""As list""''

Metavariable represented as list matches practically anything.


[[[ label = asListExample | language = Smalltalk
    `variable "is replaced with" `@variable
]]]


''""Recurse into""''

Expression ''`@variable size'' matches ''self size size'' once, where ''`@variable'' is ''self size''.
But recursive metavariable in expression ''``@variable size'' matches ''self size size'' twice.
First time ''``@variable'' is ''self size'' and second time it is ''self''.


[[[ label = asListExample | language = Smalltalk
    `@variable "is replaced with" ``@variable
]]]


''""Change""''

Replaces selected node of AST with users input.

''""Change selector""''

Replaces selector of selected node of AST with users input.

''""Ignore""''

Removes selected node of AST.

''""Ignore selector""''

Removes selector of selected node of AST.

''""Undo on node""''

Sets selected node of AST in previous state.


[[[ label = undoOnNodeExample | language = Smalltalk
    self "Abstract variable =>" `variable
    `variable "Undo on node =>" self
]]]

!!!Working with rewrite rules

This section provides useful tips about working in rewrite rule builder.
It will help you to understand the mechanics of building rule with ''Rewrite tool''.

!!!!""Equal nodes""

First thing worth mentioning is that any action, except ''Ignore'' actions, applied in ''Match rule'' pane,
also applies to all same object in ''Match rule'' pane and ''Transform rule'' pane.
If it is applied in ''Transform rule'' pane, only objects in it are transformed, but not in ''Match rule'' pane.
When I say "same object", it means equal nodes of AST.
Example:

[[[ label = tipsExample1 | language = Smalltalk
    "Code below is useless - just an example"

    "Match rule pane:"
    self children do: [ :each | each check ].
    self ifNotNil: [ self children last remove ].
    ^ self size
    
    "Transform rule pane:"
    self children do: [ :each | each check ].
    self ifNotNil: [ self children last remove ].
    ^ super size
]]]

Select ''self'' in ''Match rule'' pane and apply ''Abstract variable'' action.
You will, see the next result:

[[[ label = tipsExample2 | language = Smalltalk
    "Code below is useless - just an example"

    "Match rule pane:"
    `variable1 children do: [ :each | each check ].
    `variable1 ifNotNil: [ `variable1 children last remove ].
    ^ `variable1 size
    
    "Transform rule pane:"
    `variable1 children do: [ :each | each check ].
    `variable1 ifNotNil: [ `variable1 children last remove ].
    ^ super size
]]]
Create new metavariable

!!!!""Non-existing metavariables""

Another thing, that you shuld know is that you can't create new metavariable in ''Transform rule'' pane,
if it's not created in ''Match rule'' pane.
Meaning, that you are not able to apply, for example, ''Abstract block'' action in ''Transform rule'' pane,
if there is no metavariable in ''Match rule'' pane.
If there is one, system will suggest you to choose name from existing metavariables.
Let's take previous example:

[[[ label = tipsExample1 | language = Smalltalk
    "Code below is useless - just an example"

    "Match rule pane:"
    self children do: [ :each | each check ].
    self ifNotNil: [ self children last remove ].
    ^ self size
    
    "Transform rule pane:"
    self children do: [ :each | each check ].
    self ifNotNil: [ self children last remove ].
    ^ super size
]]]

In case you select ''super'' in ''Transform rule'' pane and apply ''Abstract variable'' action, an error will be raised.
But if you previously done this process in ''Match rule'' pane with ''self'' variable,
it's possible now to create metavariables in ''Transform rule'' pane.
If you now select ''super'' in  ''Transform rule'' pane and apply ''Abstract variable'' action window will be displayed.
With other actions like ''Abstract literal'', ''Abstract condition'' etc. happens exactly the same thing.

!!!!""Manual editing""

One more important thing is that creating rewrite rules with manual editing, instead of action click menu options, is not recommended.
First of all, you will not have general ''Undo'' as well as ''Undo on node'' options available.
Moreover you may make mistake in rewrite engine syntax.
And also, it is possible to get errors from, for example, creating non-existing metavariables.
To sum up, rewrite rule builder allows you to edit rules, but do it only if really necessary.

"IN DEVELOPEMENT!"

!!!Details of rewrite rule browser

[[[ label = nothing | language = Smalltalk
    "Nothing here for now"
]]]

"IN DEVELOPEMENT!"
