<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <title>{Pharo For the Entreprise}</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- Highlight js -->
    <link rel="stylesheet" href="../_support/html/highlightjs/styles/default.css">
    <link rel="stylesheet" href="../_support/html/css/highlight-commands.css">
    <script src="../_support/html/highlightjs/highlight.pack.js"></script>
    <script src="../_support/html/js/highlight-commands.js"></script>

    <!-- Bootstrap -->
    <link href="../_support/html/css/bootstrap.min.css" rel="stylesheet">
    <link href="../_support/html/css/bootstrap-theme.min.css" rel="stylesheet">
    <style>
        .container { max-width: 55em; }
    </style>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
      <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->
  </head>
  <body>

    <div class="container text-justify">
      <h2>I. The Rewrite Tool</h2>
<p><em>'<strong>TODO:</strong> do a full pass on this chapter, fill in where indicated; layout figures/sections; 
change option naming (as list, recurse into etc.);</em>'</p>
<h3>I.1. Introduction</h3>
<p>The purpose of this chapter is to explain what is The Rewrite Tool, why do we need
it and how to use it properly. In this chapter we also explain how The Rewrite
Tool works. Inasmuch our tool uses The Rewrite Engine we describe its general concepts. 
With this engine we are able to create expressions which can be used to match and transform code. 
Often we encounter a situation when we want to transform some part of code in many different places 
to improve its quality and readability. Also code transformations are performed in order to change an API. 
Let us look at simple example of code transformation. </p>
<p><figure><pre><code class="smalltalk">  &quot;Source code&quot;
  self isNil ifTrue: [ ^ true ] 
  
  &quot;Resulting code&quot;
  self ifNil: [ ^ true ]</code></pre><figcaption></figcaption></figure></p>
<p>Consider that we want to transform all code, that has same structure as source code, 
within few specific packages, into a code, that would have the same structure as a resulting code in example. 
To carry out this code transformation manually on a big system, i.e. with large code base, 
one would have to spend a lot of time. Also manual code transformation is an error-prone and complex process, 
inasmuch one can easily miss a code, that matches source code structure. The last, but not the least problem 
of manual code transformation is following: if one transforms code (consider transformation from example) by hand 
and after some time wants to do same or similar transformation on other packages, he has to redo all the work. 
This means, that transformation implemented previously is not saved, thus it is not reusable.
However, you can use The Rewrite Engine to transform all of code in the way you want, if only you know how. 
The syntax of DSL (domain specific language) of The Rewrite Engine is not very straightforward and sometimes even confusing, 
that is why it may be a problem to create specific rules to match and transform code. 
Moreover, even if you know engine syntax perfectly, it is very easy to make a simple but important mistake, 
for instance, miss a dot or misspell some part of rewrite expression. Such a mistake may have a huge impact 
on the result of code transformation, however you will not be notified by system about an error. </p>
<p>As you may have guessed, The Rewrite Tool helps to solve such a problems. 
It provides an intuitive GUI (graphical user interface) which allows user to create rewrite rules 
without knowledge of specific syntax, that is used in DSL of The Rewrite Engine. Moreover, after rule is created 
the tool ebables user to apply it to desired environment scope: packages, classes, methods. 
In addition, The Rewrite Tool saves all the rules in your image. This allows you to reuse transformation rules 
in future for same or similar code transformations. 
Also, you are able to modify rules later, as they are stored as classes.</p>
<p>In this chapter, we describe the tool itself in general. Then, we will take a look at examples that will show 
you The Rewrite Tool in work. After that, we will go in more details about tool and how it works.</p>
<h3>I.2.  Getting started</h3>
<p>To begin, you need to load The Rewrite Tool into your image. In order to do this, 
execute one of the following scripts.</p>
<p><figure><pre><code class="smalltalk">  &quot;Stable version for Pharo 4&quot;
  Metacello new 
    smalltalkhubUser: 'Pharo' project: 'MetaRepoForPharo40';
    configuration: 'RewriteTool';
    load
	
  &quot;Development version for Pharo 5&quot;
  Metacello new 
    smalltalkhubUser: 'MarkRizun' project: 'RewriteTool';
    configuration: 'RewriteTool';
    version: #development;
    load</code></pre><figcaption></figcaption></figure></p>
<p>An alternative way to retrieve and load The Rewrite Tool is to use the Configuration Browser in Pharo 4 
(Catalog Browser in Pharo 5). Just type in the search pane &quot;RewriteTool&quot; (without quotes) 
like on the figure 1.1 and load the project.</p>
<p><a name="fig:configurationBrowser"></a><figure><img src="figures/configurationBrowser.png"></img><figcaption>1.1. Configuration Browser in Pharo 4</figcaption></figure></p>
<h3>I.3. Rewrite rule builder</h3>

<p><strong>everything below not yet reviewed</strong></p>
<p>As soon as you have loaded The Rewrite Tool into your image, two new options appear under the &quot;Tools&quot; tab in world menu. </p>

<p><figure><pre><code class="smalltalk">RewriteRuleBuilder new openWithSpec.</code></pre><figcaption></figcaption></figure></p>
<p>As illustrated in figure <a href="rewriteRuleBuilder"></a>, builder has four panes and three
buttons, and each of this items has its own functions.  It provides a
possibility, with simple GUI, to build rewrite rules dynamically.</p>
<p><a name="fig:rewriteRuleBuilder"></a><figure><img src="figures/rewriteRuleBuilder.png"></img><figcaption>1.2. Rewrite rule builder</figcaption></figure></p>
<p><strong>Panes</strong></p>
<p><em>TODO: rename panes labels when it will be done in the software</em></p>
<ul><li>Top left pane, labeled <em>&quot;Source expression&quot;</em>, contains source code of expression which will be matched and then transformed. It means, that you should input in this pane whatever you want to transform into something else. Next it is called as <em>Source pane</em>.</li></ul>
<ul><li>Bottom left pane with label <em>&quot;Match rule&quot;</em>, is your playground. Here you will create matching part — the pattern — of rewrite rule. You can change the pattern either using action-click menu or manually changing the code. Later it is referenced as <em>Match pane</em>.</li></ul>
<ul><li>Bottom right pane is pretty much the same as previous one. Here you have label</li></ul><p><em>&quot;Transform rule&quot;</em>. It is a second part of rewrite rule. In this pane you can
create the action of the transformation rule also with options in action-click
menu, or just manually typing code. Similar to previous one it is called in rest of chapter <em>Transform pane</em>.</p>
<ul><li>The last one, but not the least important, is top right pane - <em>&quot;Result
expression&quot;</em>. It displays the result of applying a rewrite rule, composed of</li></ul><p>the two bottom panes, to a source expression. You should note that this pane is
the only one that is not editable, so it is read only. Later, this pane is referenced as <em>Result pane</em>.</p>
<p><strong>Buttons</strong></p>
<ul><li> &quot;Undo&quot; button is a general undo for the three editable panes: Source, Match</li></ul><p>  and Transform. All changes, that were made in one of these panes, are
  stacked. If you click on &quot;Undo&quot; button, the last change that was made in any
  of these panes, will be reverted. Also there is local undo for each pane
  separately.</p><ul><li> &quot;Generate rule&quot; button creates new class which is a subclass of</li></ul><p>  <em>RBTransformationRule</em> using information from two bottom panes. After the
  rule is created using this button, you can apply it to specific scope.</p><ul><li> &quot;Browse rules&quot; button opens up &quot;Rewrite rule browser&quot;, which allows you to</li></ul><p>  browse created rules, and apply them to scope that you want.</p>
<h4>I.3.A. Rewrite rule browser</h4>
<p>The browser can be launched by typing the following code in your Pharo
workspace:
<figure><pre><code class="smalltalk">RewriteRuleBrowser new openWithSpec.</code></pre><figcaption></figcaption></figure></p>
<p>The browser is shown on figure <a href="rewriteRuleBrowser"></a>. This tool contains all
previously created rewrite rules in most left pane. It also displays all
packages, classes, protocols and methods that are present in the current image.</p>
<p>You can select a rewrite rule that you want to apply. Then choose a scope,
which you want to be transformed with this rule and click &quot;Apply rule to
selected scope&quot; button. A multiple selection can be done by pressing <em>Shift</em>
key while clicking on the first and the last package, class, protocol or
method. After applying a rule, a confirmation window which shows changes
appears. You can accept or cancel them.</p>
<p>To browse selected rewrite rule class, click &quot;Browse selected rule&quot; button.</p>
<p><a name="fig:rewriteRuleBrowser"></a><figure><img src="figures/rewriteRuleBrowser.png"></img><figcaption>1.3. Rewrite rule browser</figcaption></figure></p>
<h3>I.4. Examples</h3>
<p>In this part you can find useful examples, that will help you to understand how to create your own rule using Builder.
Following examples are meant to teach you basics of using Builder.</p>
<h4>I.4.A. First example</h4>
<p>Back to example, we would like to transform the following snippet of code:</p>
<p><figure><pre><code class="smalltalk">    self isNil ifTrue: [ ^ true ] </code></pre><figcaption></figcaption></figure></p>
<p>into:</p>
<p><figure><pre><code class="smalltalk">    self ifNil: [ ^ true ]</code></pre><figcaption></figcaption></figure></p>
<h5>I.4.A.a. Step 1:</h5>
<p>First, you need to input template source code in Source pane of Builder. If you
launched the builder with the previously given line, the input code is the one
of our example. In all panes you get exactly the same code. If you want to
create your own rewrite rule, just type or copy-paste the code on which you
would like to apply a transformation in the Source pane. Be sure to save any
changes in the pane in order to have the right result.</p>
<p>To start with, look at status bar in Match pane. Obviously, for now it says &quot;matches&quot;, as source code and match rule are equal.
This status bar will help you to create rule, that will really correspond to source code.
If it changes to &quot;doesn't match&quot;, you probably should use &quot;Undo&quot; button, and rethink your next move.
As was mentioned earlier, your main playground is Match pane.
Thus, almost all next actions are made in this pane, and also in Transform pane.
In our example we don't care about the concerned object (<em>self</em>).
It can be <em>self</em> or maybe just some temporary variable.
That is why you have to select <em>self</em> and right click on it, which opens a
menu.</p>
<p><a name="simpleExample1-1"></a><figure><img src="figures/simpleExample1-1.png" width="60%"></img><figcaption>1.4. Step 1 of simple example</figcaption></figure>
As shown in figure <a href="simpleExample1-1"></a>, it displays all actions that can be
applied to selected object. Actually this object is represented as a node of
an AST (abstract syntax tree). In Builder each node of AST has its own set of
options we will note detail here. For more information on abstract syntax tree
<em><strong>you may read HERE</strong></em>.
In this particular case it will contain following options:</p><ul><li> Ignore</li><li> Change</li><li> Abstract variable </li></ul><p>You need <em>&quot;Abstract variable&quot;</em>, inasmuch it changes <em>self</em> into
metavariable, as illustrated in figure <a href="simpleExample1-2"></a>.
<a name="simpleExample1-2"></a><figure><img src="figures/simpleExample1-2.png" width="60%"></img><figcaption>1.5. End of step 1 of simple example</figcaption></figure></p>
<p>You can read more about metavariables and The Rewrite Engine <em><strong>HERE</strong></em>.</p>
<p>This metavariable will match any object for example: <em>self</em>, <em>Color</em> (classes are objects too), <em>someTempVar</em>.
After this change we should have:</p>
<p><figure><pre><code class="smalltalk">    `variable1 isNil ifTrue: [ ^ true ] </code></pre><figcaption></figcaption></figure></p>
<p>And status bar also has to be unchanged, saying: <em>matches</em>.
As you may noticed Transform pane text also was changed in following way:</p>
<p><figure><pre><code class="smalltalk">    `variable1 ifNil: [ ^ true ]</code></pre><figcaption></figcaption></figure></p>
<p>It means that in result on the place of <em>self</em> we will get <em>self</em>.
In case you want to have in result something else, for example
<em>anotherObject</em> use an option <em>Change</em> on a `variable1 in Transform pane
(or manually type it, but it is not recommended).
But for now, we don't want that.</p>

<h5>I.4.A.b. Step 2:</h5><p><a name="simpleExample1-3"></a><figure><img src="figures/simpleExample1-3.png" width="60%"></img><figcaption>1.6. Step 2 of simple example</figcaption></figure></p>
<p>The next step concerns <em>isNil</em>: select it in Transform pane and right-click
to open a menu. The options in this case are different from previous one, as it
is not a variable selected, but selector. So, click on <em>Ignore selector</em>
option. It will remove <em>isNil</em> from Transform pane.
Also, Result pane was updated.%:</p>

<h5>I.4.A.c. Step 3:</h5>
<p><a name="simpleExample1-4"></a><figure><img src="figures/simpleExample1-4.png" width="60%"></img><figcaption>1.7. Step 3 of simple example</figcaption></figure></p>
<p>Now let us work with our block: <em>[ ^ true ]</em>. We have the same situation as
we had with <em>self</em>. Once again, we don't care about which block is passed as
an argument to <em>ifTrue:</em> or <em>ifNil:</em>. Therefore in Match pane, we select
our block (be sure to include the brackets) and choose the option <em>Abstract
block</em> as examplefied in figure <a href="simpleExample1-4"></a>. In result it will be
changed into <em>`@block1</em>.</p>
<h5>I.4.A.d. Step 4:</h5>
<p><a name="simpleExample1-5"></a><figure><img src="figures/simpleExample1-5.png" width="60%"></img><figcaption>1.8. Step 4 of simple example</figcaption></figure></p>
<p>Finally, select <em>ifTrue:</em> in Transform pane, and apply <em>Change selector</em>
option from menu. Type in recently opened window: <em>ifNil:</em>, and press <em>Ok</em>
button as shown by figure <a href="simpleExample1-5"></a>. </p>
<p>You can also select <em>super size</em> and ignore it in Match and Transform panes,
and then delete it in the source one to finish the transformation and obtaining
the same rule as in <a href="simpleExample1-6"></a>.</p>
<p><a name="simpleExample1-6"></a><figure><img src="figures/simpleExample1-6.png" width="60%"></img><figcaption>1.9. Step 5 of simple example</figcaption></figure></p>
<p>You can see the result of applying rewrite rule to source code in Result pane.</p>
<p><figure><pre><code class="smalltalk">    self ifNil: [ ^ true ]</code></pre><figcaption></figcaption></figure></p>
<p>You can click on <em>Generate rule</em> button to automatically generate a class for your new rule.
Than click on <em>Browse rules</em> button, and you will see that your new class is in Browser.</p>
<p><strong>...(HERE MAY BE DESCRIBED HOW TO USE BROWSER)...</strong></p>

<h4>I.4.B. Second example</h4>
<p>To understand the following example, the previous one which transforms <em>isNil
ifTrue:[ ... ]</em> into <em>ifNil[ ... ]</em> has to be understood. If not, please
take your time and go back to be sure you know the basics.</p>
<p>This time we are going to recreate one of rules that already exists in Critic
Browser. We choose the one called <code>RBMinMaxRule</code>. It has a method initialize
where all rules are initialized. There you can see that <code>RBMinMaxRule</code> has
many rules that are similar to each other. Thus let us take a look only at one
of them. Suppose we have a snippet of code which returns the max of two objects
and which is written as follows:</p>
<p><figure><pre><code class="smalltalk">    temp := a &lt; b
	ifTrue: [ a ]
	ifFalse: [ b ]</code></pre><figcaption></figcaption></figure></p>
<p>where <em>temp</em> is a temporary variable. Let us suppose that the objects <em>a</em>
and <em>b</em> are comparable, for instance integers.  This piece of code does
simple assignment of bigger number (<em>a</em> or <em>b</em>) to the temporary variable
<em>temp</em>. However it is written in a bad way.  We would rather write a simpler
and more beautiful snippet of code as illustrated in the following script:</p>
<p><figure><pre><code class="Smalltalk">    temp := a max: b</code></pre><figcaption></figcaption></figure></p>
<p>This version is more readable and other people can easily understand what this code does.
In order to create a rule that will do the transformation as presented before, we will use our Builder.</p>
<h5>I.4.B.a. Step 1:</h5><p>First of all, launch the Builder and type this input code into Source and Match
panes (the left ones):</p>
<p><figure><pre><code class="smalltalk">    temp := a &lt; b
	ifTrue: [ a ]
	ifFalse: [ b ]</code></pre><figcaption></figcaption></figure></p>
<p>Then enter this code into the Transform pane (the bottom right one):</p>
<p><figure><pre><code class="smalltalk">    temp := a max: b</code></pre><figcaption></figcaption></figure></p>
<p><a name="example2-1"></a><figure><img src="figures/example2-1.png" width="60%"></img><figcaption>1.10. Step 1 of max transformation example</figcaption></figure></p>
<h5>I.4.B.b. Step 2:</h5><p>Now select <em>temp</em> in Match pane and mark it as an <em>Abstract variable</em> with
the contextual menu (right click). Apply the same operation on <em>a</em> and <em>b</em>.
After this step, your Match panel should look like the following snippet of
code:</p>
<p><figure><pre><code class="smalltalk">    `variable1 := `variable2 &lt; `variable3
	ifTrue: [ `variable2 ]
	ifFalse: [ `variable3 ]</code></pre><figcaption></figcaption></figure></p>
<p><strong>Note:</strong> Variable names may be different if you did other changes before
trying this example.</p>
<p>As for the Transform panel, it should be very similar to the following code:</p>
<p><figure><pre><code class="smalltalk">    `variable1 := `variable2 max: `variable3</code></pre><figcaption></figcaption></figure>
If you want to match and transform only expressions where <em>a</em> and <em>b</em> are
simple variables, this rule is sufficient. </p>
<p><a name="example2-2"></a><figure><img src="figures/example2-2.png" width="60%"></img><figcaption>1.11. Step 2 of max transformation example</figcaption></figure></p>
<h5>I.4.B.c. Step 3:</h5><p>However if you need something more complex, for instance <em>a</em> is some
expression that does calculations and that returns a result, you will have to
go on with the example.  Select <em>`variable2</em> and mark it as <em>As list</em> with
the contextual menu. Then apply <em>Recurse into</em> on <em>`@variable2</em> which
results in the following snippet of code in Match panel:</p>
<p><figure><pre><code class="smalltalk">  `variable1 := ``@variable2 &lt; `variable3
	ifTrue: [ ``@variable2 ]
	ifFalse: [ `variable3 ]</code></pre><figcaption></figcaption></figure></p>
<p>And in the Transform panel:</p>
<p><figure><pre><code class="smalltalk">    `variable1 := ``@variable2 max: `variable3</code></pre><figcaption></figcaption></figure></p>
<p>If necessary, you can do exactly the same thing with <em>b</em> (<em>`variable3</em> in
the previous snippet). After few simple actions we got the result which we
expected.</p>
<p><a name="example2-3a"></a><figure><img src="figures/example2-3a.png" width="60%"></img><figcaption>1.12. Step 3 (a) of max transformation example</figcaption></figure>
<a name="example2-3b"></a><figure><img src="figures/example2-3b.png" width="60%"></img><figcaption>1.13. Step 3 (b) of max transformation example</figcaption></figure></p>
<h5>I.4.B.d. Step 4:</h5><p>Use <em>Generate rule</em> button to generate the class of this rule in order to use
it in the Browser.</p>

<h4>I.4.C. Third example</h4>
<p><strong>...Probably we have to put explanation to The Rewrite Engine before examples, or just give some link...</strong></p>
<p>Class <code>RBMinMaxRule</code> is a subclass of <code>RBTransformationRule</code>, which has other not less interesting examples of rewrite rules. 
That is why we will examine <code>RBAtIfAbsentRule</code>. 
This one works with collections and blocks, so its implementation may be more complicated than implementation of rules in two previous examples,
 however it is still easy to understand. </p>
<p>Again, open <code>RBAtIfAbsentRule&gt;&gt;#initialize</code> method, and you will see few, similar to each other, rules. 
Here is one of them:</p>
<p><figure><pre><code class="smalltalk">    self rewriteRule
	&quot;...&quot;
	replace: '``@dictionary at: ``@key
		  ifAbsent: [| `@temps |
	          ``@.Statements.
	          ``@dictionary at: ``@key 
                  put: ``@object]'
	with:    '``@dictionary at: ``@key
	          ifAbsentPut: [| `@temps |
	          ``@.Statements.
	          ``@object]'</code></pre><figcaption></figcaption></figure></p>
<p>At first look it may seem too complex, but after we generate it with builder, you will clearly know the responsibilities of each part of this rule.
With such a rule we can do followning transformation:</p>
<p><figure><pre><code class="smalltalk">    	&quot;before rule is applied&quot;

	| myDictionary |
	myDictionary := Dictionary new 
		at: 1 put: 'a';
		at: 2 put: 'b';
		yourself.
	myDictionary at: 3 ifAbsent: [
	 | temp1 temp2 temp3 | 
	 temp1 := 'c'.
	 temp2 := 'd'.
	 temp3 := temp1, temp2.
	 myDictionary at: 3 put: temp3 ].
	 ^ myDictionary

	&quot;after rule is applied&quot;

	| myDictionary |
	myDictionary := Dictionary new
		at: 1 put: 'a';
		at: 2 put: 'b';
		yourself.
	myDictionary at: 3 ifAbsentPut: [ 
	 | temp1 temp2 temp3 |
	 temp1 := 'c'.
	 temp2 := 'd'.
	 temp3 := temp1 , temp2.
	 temp3 ].
	^ myDictionary</code></pre><figcaption></figcaption></figure></p>
<p>This code contains all keywords that are present in rule such as: #at:ifAbsent:, and #at:ifAbsentPut:. 
Current example is using this code, to implement the rule, that we selected earlier.</p>
<h5>I.4.C.a. Step 1:</h5>
<p>In order to open Builder with previous code inside of it, select first part of code (the one that is before rule is applied)
 in Nautilus workspace, go to <em>Source code refactoring</em> and select <em>RewriteRuleBuilder</em> option. 
Or you can just open Builder through <em>World menu &gt;&gt; Tools &gt;&gt; Builder</em>,
 and than copy and paste first part of code in Source and Match panels, and second part - in Transform panel.
Next copy second part of code, and paste it into Transform panel. 
Now we are ready to implement the rule.</p>
<p><a name="example3-1"></a><figure><img src="figures/example3-1.png" width="60%"></img><figcaption>1.14. Step 1 of ifAbsent: transformation example</figcaption></figure></p>
<h5>I.4.C.b. Step 2:</h5><p>Required code is inside of the Builder, so it is time to begin creating the rule.
As always, all following actions are done in Match panel, unless other panel is specified. 
To start with, select any reference of <code>myDictionary</code>, except one that is a variable declaration,
 and apply <em>Abstract variable</em> option. 
After that, do <em>As List</em> on newely created metavariable <code>`variable1</code>. 
You will get <code>`@variabl1</code>, and finally, apply <em>Recurse into</em> to this one.
The result is <code>``@variable1</code>, and all in all it is: </p>
<p>Despite tha fact, that we don't need recursion and list symbol in this particular situation, 
we still use them, because of next reasons:</p><ul><li> to get exactly the same rule as we have in <code>RBAtIfAbsentRule</code>;</li><li> to create a rule that can be used in general situation, not only in particular one;</li><li> to learn which actions Builder is able to perform.</li></ul>
<p>Now we do exactly the same actions with a key, which is equal to 3.</p>
<p><a name="example3-2"></a><figure><img src="figures/example3-2.png" width="60%"></img><figcaption>1.15. Step 2 of ifAbsent: transformation example</figcaption></figure></p>
<h5>I.4.C.c. Step 3:</h5>
<p>Apply <em>Abstract statement</em> action to next snippet:</p>
<p><figure><pre><code class="smalltalk">    	&quot;...&quot;

	``@variable1 := Dictionary new
	at: 1 put: 'a';
	at: 2 put: 'b';
	yourself.

	&quot;...&quot;</code></pre><figcaption></figcaption></figure></p>
<p>Basically, we want to match here pretty much everything, so let us do <em>As List</em> and <em>Recurse into</em> on <code>`.Statement1</code>, and as a result we have <code>``@.Statement1</code>.
To finish with initialization part of this code, select declaration of temporary variable <code>| myDictionary |</code> and do on it <em>Abstract temporaries list</em>.
Note, that <code>| myDictionary |</code> in Transform panel wasn't transformed to <code>| ``@temporaries |</code>, so we have to do it ourselves. 
Select <code>| myDictionary |</code> in Transform panel, and apply <em>Abstract temporaries list</em>. 
In opened window select <code>| ``@temporaries |</code> option.</p>
<h5>I.4.C.d. Step 4:</h5>
<p>After this steps, lets take a look at the argument of <code>#ifAbsent:</code> - a block. 
With temporaries declaration <code>| temp1 temp2 temp3 |</code> we do exactly the same thing as in previous step. 
Also we have to do same actions in Transform panel, but now in opened window choose <code>| ``@temporaries2 |</code> instead of <code>| ``@temporaries1 |</code>. </p>
<p>Apply <em>Abstract statement<strong>s</strong></em> action to next snippet:</p>
<p><figure><pre><code class="smalltalk">    	&quot;...&quot;

	temp1 := 'c'.
	temp2 := 'd'.
	temp3 := temp1 , temp2.

	&quot;...&quot;</code></pre><figcaption></figcaption></figure></p>
<p>Than do it with same snippet in Transform panel, and choose <code>`@.Statements2</code>. 
Next, back to Match panel, on <code>`@.Statements2</code> node do <em>Recurse into</em>. 
The rule is almost ready, there is one variable left that we have to change - <code>temp3</code>. 
Select it and use <em>Abstract variable</em>, <em>As List</em> and <em>Recurse into</em> actions one after another, and that is how you get <code>``@variable3</code>. 
Finally we have our rule, which does exactly what we wanted - transformation that is mentioned in the beginning of this example. </p>
<p><a name="example3-4"></a><figure><img src="figures/example3-4.png" width="60%"></img><figcaption>1.16. Step 4 of ifAbsent: transformation example</figcaption></figure></p>
<p>If you wish, now it is possible to <em>Generate</em> a class, that will hold this rule, so afterwars you can use it in Browser. </p>
<p><strong>... Again, maybe explained Browser ...</strong></p>

<h3>I.5. The Rewrite Tool in details</h3>
<p>In this section we describe each and every part of The Rewrite Tool. It is grounded
on many important ideas that are explained here. A good understanding of this
ideas is crucial to increase users effectiveness, while working with the tool.</p>
<h4>I.5.A. Menu options</h4>
<p>List of all available options (may be changed):</p><ul><li> Abstract block</li><li> Abstract condition</li><li> Abstract literal</li><li> Abstract statement</li><li> Abstract variable</li><li> As list</li><li> Recurse into</li><li> Change</li><li> Change selector</li><li> Ignore</li><li> Ignore selector</li><li> Undo on node</li></ul>
<p><strong>... Update list of options ...</strong></p>
<h5>I.5.A.a. <strong>Abstract actions</strong></h5>
<p>Any of abstract action replaces selected object(s) with metavariable that
corresponds to selected node of AST. Next is described what can be matched with
the metavariable in each case.</p>
<p><strong>Note:</strong> each metavariable name ends with an index, but for readability
reasons it is not displayed in the examples below.</p>
<p><em><strong>Abstract block</strong></em></p>
<p>Matches any block.</p>
<p><figure><pre><code class="smalltalk">    [ &quot;a lot of stuff here&quot; ] &quot;replaced with&quot; `@block</code></pre><figcaption></figcaption></figure></p>

<p><em><strong>Abstract condition</strong></em></p>
<p>Matches any condition.</p>
<p><figure><pre><code class="smalltalk">    self isNil ifTrue: [ ^ true ] &quot;is replaced with&quot; `@condition ifTrue: [ ^ true ]</code></pre><figcaption></figcaption></figure></p>
<p><em><strong>Abstract literal</strong></em></p>
<p>Matches any literal.</p>
<p><figure><pre><code class="smalltalk">    true &quot;is replaced with&quot; `#literal
    119 &quot;is replaced with&quot; `#literal</code></pre><figcaption></figcaption></figure></p>
<p><em><strong>Abstract statement</strong></em></p>
<p>Matches any statement, but not list of statements.</p>
<p><figure><pre><code class="smalltalk">    self isNil ifTrue: [ ^ true ] &quot;is replaced with&quot; `.Statement</code></pre><figcaption></figcaption></figure></p>
<p><em><strong>Abstract variable</strong></em></p>
<p>Matches any variable.</p>
<p><figure><pre><code class="smalltalk">    self &quot;is replaced with&quot; `variable</code></pre><figcaption></figcaption></figure></p>
<h5>I.5.A.b. <strong>Other actions</strong></h5>
<p><em><strong>As list</strong></em></p>
<p>Metavariable represented as list matches practically anything.</p>

<p><figure><pre><code class="smalltalk">    `variable &quot;is replaced with&quot; `@variable</code></pre><figcaption></figcaption></figure></p>

<p><em><strong>Recurse into</strong></em></p>
<p>Expression <em>`@variable size</em> matches <em>self size size</em> once, where <em>`@variable</em> is <em>self size</em>.
But recursive metavariable in expression <em>``@variable size</em> matches <em>self size size</em> twice.
First time <em>``@variable</em> is <em>self size</em> and second time it is <em>self</em>.</p>

<p><figure><pre><code class="smalltalk">    `@variable &quot;is replaced with&quot; ``@variable</code></pre><figcaption></figcaption></figure></p>

<p><em><strong>Change</strong></em></p>
<p>Replaces selected node of AST with users input. Contrary to a manual change,
all occurences are modified in the different panes.</p>
<p><em><strong>Change selector</strong></em></p>
<p>Replaces selector of selected node of AST with users input.</p>
<p><em><strong>Ignore</strong></em></p>
<p>Removes selected node of AST. This option is used when a part of the code is
not useful or relevant for the pattern.</p>
<p><em><strong>Ignore selector</strong></em></p>
<p>Removes selector of selected node of AST.</p>
<p><em><strong>Undo on node</strong></em></p>
<p>Sets selected node of AST in previous state.</p>

<p><figure><pre><code class="smalltalk">    self &quot;Abstract variable =&gt;&quot; `variable
    `variable &quot;Undo on node =&gt;&quot; self</code></pre><figcaption></figcaption></figure></p>
<h4>I.5.B. Working with rewrite rules</h4>
<p>This section provides useful tips about working in rewrite rule builder.
It will help you to understand the mechanics of building rule with <em>The Rewrite Tool</em>.</p>
<h5>I.5.B.a. <strong>Equal nodes</strong></h5>
<p>First thing worth mentioning is that any action, except <em>Ignore</em> actions, applied in <em>Match rule</em> pane,
also applies to all same object in <em>Match rule</em> pane and <em>Transform rule</em> pane.
If it is applied in <em>Transform rule</em> pane, only objects in it are transformed, but not in <em>Match rule</em> pane.
When I say &quot;same object&quot;, it means equal nodes of AST.
Example:</p>
<p><figure><pre><code class="smalltalk">    &quot;Code below is useless - just an example&quot;

    &quot;Match rule pane:&quot;
    self children do: [ :each | each check ].
    self ifNotNil: [ self children last remove ].
    ^ self size
    
    &quot;Transform rule pane:&quot;
    self children do: [ :each | each check ].
    self ifNotNil: [ self children last remove ].
    ^ super size</code></pre><figcaption></figcaption></figure></p>
<p>Select <em>self</em> in <em>Match rule</em> pane and apply <em>Abstract variable</em> action.
You will, see the next result:</p>
<p><figure><pre><code class="smalltalk">    &quot;Code below is useless - just an example&quot;

    &quot;Match rule pane:&quot;
    `variable1 children do: [ :each | each check ].
    `variable1 ifNotNil: [ `variable1 children last remove ].
    ^ `variable1 size
    
    &quot;Transform rule pane:&quot;
    `variable1 children do: [ :each | each check ].
    `variable1 ifNotNil: [ `variable1 children last remove ].
    ^ super size</code></pre><figcaption></figcaption></figure>
Create new metavariable</p>
<h5>I.5.B.b. <strong>Non-existing metavariables</strong></h5>
<p>Another thing, that you shuld know is that you can't create new metavariable in
<em>Transform rule</em> pane, if it is not created in <em>Match rule</em> pane. Meaning,
that you are not able to apply, for example, <em>Abstract block</em> action in
<em>Transform rule</em> pane, if there is no metavariable in <em>Match rule</em> pane.
If there is one, system will suggest you to choose name from existing
metavariables. Let us take previous example:</p>
<p><figure><pre><code class="smalltalk">    &quot;Code below is useless - just an example&quot;

    &quot;Match rule pane:&quot;
    self children do: [ :each | each check ].
    self ifNotNil: [ self children last remove ].
    ^ self size
    
    &quot;Transform rule pane:&quot;
    self children do: [ :each | each check ].
    self ifNotNil: [ self children last remove ].
    ^ super size</code></pre><figcaption></figcaption></figure></p>
<p>In case you select <em>super</em> in <em>Transform rule</em> pane and apply <em>Abstract variable</em> action, an error will be raised.
But if you previously done this process in <em>Match rule</em> pane with <em>self</em> variable,
it is possible now to create metavariables in <em>Transform rule</em> pane.
If you now select <em>super</em> in  <em>Transform rule</em> pane and apply <em>Abstract variable</em> action window will be displayed.
With other actions like <em>Abstract literal</em>, <em>Abstract condition</em> etc. happens exactly the same thing.</p>
<h5>I.5.B.c. <strong>Manual editing</strong></h5>
<p>One more important thing is that creating rewrite rules with manual editing, instead of action click menu options, is not recommended.
First of all, you will not have general <em>Undo</em> as well as <em>Undo on node</em> options available.
Moreover you may make mistake in The Rewrite Engine syntax.
And also, it is possible to get errors from, for example, creating non-existing metavariables.
To sum up, rewrite rule builder allows you to edit rules, but do it only if really necessary.</p>
<p>&quot;IN DEVELOPEMENT!&quot;</p>
<h4>I.5.C. Details of rewrite rule browser</h4>
<p><figure><pre><code class="smalltalk">    &quot;Nothing here for now&quot;</code></pre><figcaption></figcaption></figure></p>
<p>&quot;IN DEVELOPEMENT!&quot;</p>
<h4>I.5.D. The Rewrite Engine</h4>
<p>Builder uses The Rewrite Engine to parse rules, to match and transform code. This engine works with strings, that are recognized on level of abstract syntax tree.
As a result, each part of matching or transforming string becomes a node of AST, which makes this engine very powerful.
So, The Rewrite Engine makes it possible to get an AST representation of any rule.
It means, user can easily match or replace(transform) any part of code as a node.</p>
<p>The syntax of The Rewrite Engine may seem a bit confusing, however it contains only few key symbols.
These symbols are:</p><ul><li>backquote(`)</li><li>dot(.)</li><li>number sign(#)</li><li>at sign(@)</li></ul>
<h5>I.5.D.a. Backquote symbol</h5><p><figure><pre><code class="smalltalk">`</code></pre><figcaption></figcaption></figure>
It represents any metavariable, and other symbols specify whic kind of metavariable it is.
For example, it can be
<figure><pre><code class="smalltalk">`variable1</code></pre><figcaption></figcaption></figure>
This expression will match any simple object like: Object, super, etc. (but not literal)
Up to this point it seems to be simple, however, there is one tricky place.
<figure><pre><code class="smalltalk">`variable1
&quot;Some code&quot;
`variable2</code></pre><figcaption></figcaption></figure>
This expression will not match
<figure><pre><code class="smalltalk">myVar
&quot;Some code&quot;
myVar</code></pre><figcaption></figcaption></figure>
because we use different metavariables and equal variables.
But it will match
<figure><pre><code class="smalltalk">myVar
&quot;Some code&quot;
myAnotherVar</code></pre><figcaption></figcaption></figure>
It means, that name of metavariable is important, as it is unique.
Each metavariable has its own AST node representation.
Conclusion is, that different metavariables match different variables.
And one metavariable matches the same variable many times.</p>
<p>Also backquote symbol is responsible for recursing into message sends, statements, objects etc.
<figure><pre><code class="smalltalk">``@variable1 size</code></pre><figcaption></figcaption></figure>
This rule will match any object that has a sender size.
Moreover, whenever match is found, The Rewrite Engine looks inside of matched node for more matches.
It means that engine will search for this construction
<figure><pre><code class="smalltalk">``@variable1 size</code></pre><figcaption></figcaption></figure>
inside of this node:
<figure><pre><code class="smalltalk">``@variable1</code></pre><figcaption></figcaption></figure>
So, if you have 
<figure><pre><code class="smalltalk">self size size</code></pre><figcaption></figcaption></figure>
you will get two matches. First of all, 
<figure><pre><code class="smalltalk">``@variable1</code></pre><figcaption></figcaption></figure>
matches with reciever of size:
<figure><pre><code class="smalltalk">self size</code></pre><figcaption></figcaption></figure>
And than, our metavariable matches with
<figure><pre><code class="smalltalk">self</code></pre><figcaption></figcaption></figure></p>
<h5>I.5.D.b. Dot symbol</h5><p><figure><pre><code class="smalltalk">.</code></pre><figcaption></figcaption></figure>
It has the simplest role in The Rewrite Engine.
Dot is used to match statement in sequence node.
<figure><pre><code class="smalltalk">`.Statement1</code></pre><figcaption></figcaption></figure>
matches with
<figure><pre><code class="smalltalk">myVar asString size</code></pre><figcaption></figcaption></figure>
Obviously, it is also used as end of statement.
Working with The Rewrite Engine syntax requires a lot of attention and patience, as if you miss dot somewhere, 
it will match nothing or something you didn't want to.
In case you are using builder, it will automatically place all dots you need.
If you have couple of statements like this:
<figure><pre><code class="smalltalk">myVar := 123.
myVar asString size.</code></pre><figcaption></figcaption></figure>
it matches next The Rewrite Engine expression:
<figure><pre><code class="smalltalk">`.Statement1.
`.Statement2</code></pre><figcaption></figcaption></figure>
As was mentioned earlier, backquote states that it is metavariable, and unique name of each metavariable indicates that matched AST nodes are different.</p>
<h5>I.5.D.c. Number sign</h5><p><figure><pre><code class="smalltalk">#</code></pre><figcaption></figcaption></figure>
This symbol says that metavariable should match only literal nodes of AST.
Example:
<figure><pre><code class="smalltalk">`#literal1</code></pre><figcaption></figcaption></figure>
mathces any literal:
<figure><pre><code class="smalltalk">#(1, 2, 3) &quot;or&quot; #foo &quot;or&quot; 19 &quot;etc.&quot;</code></pre><figcaption></figcaption></figure></p>
<h5>I.5.D.d. At symbol</h5><p>Finally, we will examine functions of at sign:
<figure><pre><code class="smalltalk">@</code></pre><figcaption></figcaption></figure></p>
<p>At sign, as an element of The Rewrite Engine syntax, is used to indicate list of something: temporary variables, statements, arguments or keywords in message send.
To match any message send you have to specify any number of keywords and any number of arguments like this:
<figure><pre><code class="smalltalk">myObject `@message: `@keyword</code></pre><figcaption></figcaption></figure>
matches any message sent to myObject.
If you want to match more than one statement which are one after another it is not necessary to write:
<figure><pre><code class="smalltalk">`.Statement1.
`.Statement2.
`.Statement3.
&quot;etc.&quot;</code></pre><figcaption></figcaption></figure>
Instead use at sign together with dot symbol, and you will get equal to previous expression:
<figure><pre><code class="smalltalk">`@.Statements</code></pre><figcaption></figcaption></figure>
Also, it is possible to match list of temps this way:
<figure><pre><code class="smalltalk">| `@temporaries |</code></pre><figcaption></figcaption></figure>
In general, at symbol used with backquote
<figure><pre><code class="smalltalk">`@object</code></pre><figcaption></figcaption></figure>
matches any message, literal or block node of AST, which is really important to know.</p>
<h3>I.6. Architecture of The Rewrite Tool</h3>
<p>This section covers the architecture of The Rewrite Tool, explains responsibilities of classes.
Also it gives a clear understanding of class hierarchy, which is present in The Rewrite Tool. 
In addition to this, methods are covered too.</p>
<h4>I.6.A. AbstractPanel class</h4>
<p>Clearly, <em>AbstractPanel</em> is an abstract class,
which represents a panel that contains text field and a label.
Text field contains a code, which is considered later as an AST in order to make further manipulations with code possible.
Also in <em>AbstractPanel</em> class is implemented basic behavior of all actions,
that were described in paragraph <strong>4.1. Menu options</strong>.
Why &quot;basic behavior&quot;, you might ask?
That is so, because each of <em>AbstractPanel</em> subclasses shares this behavior, however its not complete in the abstract class.
Its subclasses represent four panels of builder and they are: <em>SourcePanel</em>, <em>MatchPanel</em>, <em>TransformPanel</em>, <em>ResultPanel</em>,
which were mentioned in <strong>2.1. Rewrite rule builder</strong> section.
Moreover <em>AbstractPanel</em> class implements update methods, which, obviously, update different information such as AST, text, current metavariables names etc.</p>
<p>Methods of <em>AbstractPanel</em> class:</p>
<p>1. <strong><code>#parse:</code></strong> parses a string as rewrite expression or method. This choise depends on return of <code>#isParsingExpression</code>. </p>
<p>2. <strong><code>#executeCommand:atIndex:withSource:</code></strong> is used to execute any command, class of which is passed as an argument.
This particular command is executed for each node that is equal to currently selected node.
Also, this method adds changes to undo dictionary, that holds all previous changes that were made.
After command is executed, update methods are invoked.</p>
<p>3. <strong><code>#updateAst</code></strong> updates AST of current panel.</p>
<p>4. <strong><code>#updateText</code></strong> updates text of current panel, that is displayed.</p>
<p>5. <strong><code>#updateInfoFor:withOld:andNew:</code></strong> updates text, ast of panel. 
Also updates <code>#oldNodes</code> property of all nodes in AST.
Invokes method, which responsibility is to update next panel. 
Next panel is Transform Panel for Match Panel, and Result Panel for Transform Panel. </p>
<p>6. <strong><code>#getAllMetavariables</code></strong> returns a collection of all metavariables that are used in current panel.</p>
<p>7. <strong><code>#difference:with:</code></strong> returns a mathematical difference of sets, however works not with sets but with collections, so duplicates are possible. </p>
<p>8. <strong><code>#isReplacementPossibleFor:</code></strong> checks a complicated condition. If it returns true, than execution of current action is permited, else it is restricted. 
The condition is: </p>
<p><figure><pre><code class="smalltalk">&quot;if after action is applied to selected (meta)variable, there still will be the same (meta)variable left in ''MatchPanel''&quot;
	((self difference: allMetavars with: selectedMetavars) &amp; selectedMetavars) size == selectedMetavars size
		and: [ 

&quot;if selected (meta)variable is used in ''TransformPanel'' or: if there are no metavars in ''MatchPanel'' and ''TransformPanel'' at all&quot;
			((selectedMetavars &amp; usedMetavars) isNotEmpty or: [ (selectedMetavars | usedMetavars) isEmpty ])

&quot;if among selected variables there are no metavariables&quot;
				or: [ selectedMetavars isEmpty ] ]</code></pre><figcaption></figcaption></figure></p>
<p>9. <strong><code>#isSelectedAll</code></strong> returns <code>true</code> if all code in current panel is selected. </p>
<p>10. <strong><code>#manageUndoDictFor:</code></strong> adds an instance of RewriteRuleChange class to <code>undoDict</code> instance variable, which holds all changes for <em>Undo</em> action. 
This variable is discussed later. Also this method enables <code>undoButton</code>. </p>
<p>All following methods open up alert windows with different message each.</p>
<p><code>#changeInvalidAlert</code>, <code>#classNotCreatedAlert</code>, <code>#noMetavariablesAlert</code>, <code>#replacementNotPossibleAlert</code>, <code>#varNotChosenAlert</code>. </p>
<p>Next, we may examine subclasses of <em>AbstractPanel</em>.</p>
<h4>I.6.B. SourcePanel class</h4>
<p>Holds source code of expression that should be transformed into something new.
Actually, <em>SourcePanel</em> implements onle one new feature that is not inherited from <em>AbstractPanel</em>.
This class states that by action-clicking (right click) there are available options in this panel - Smart Suggestions (by Gisela). 
It is done in method #menuActions, which returns an array. </p>
<p><figure><pre><code class="smalltalk">    menuActions
	| options |
	options := OrderedCollection new.
	options add: #('Smart Suggestions' #smartSuggestions).
	^ options</code></pre><figcaption></figcaption></figure> </p>
<p>To remind, instance of <em>SourcePanel</em> class is located on top left of builder.</p>
<h4>I.6.C. ResultPanel class</h4>
<p>Presents disabled text field, which means that user can not edit text contained in this panel. 
Result Panel holds result of applying rewrite rule to source code.
Located in top right part of RewriteRuleBuilder. </p>
<p><figure><pre><code class="smalltalk">    initialize
	super initialize.
	self templateText disable</code></pre><figcaption></figcaption></figure></p>
<h4>I.6.D. MatchPanel class</h4>
<p><em>MatchPanel</em> class is a subclass of <em>AbstractPanel</em>, instance of which holds matching part of rewrite rule (i.e. left hand side part of rule). 
To begin with, this class coontrols all indexes that are added after each (including some of them) metavariable name. 
When any action is taken, that creates new metavariable in rule, <em>MatchPanel</em> adds index at the end of metavariable name. 
Than index of coresponding metavariable group is incremented. 
For example, <code>MatchPanel &gt;&gt; #abstractVariable</code></p>
<p><figure><pre><code class="smalltalk">    abstractVariable
	&quot;first the action is executed, thus new metavariable is created&quot;
	super abstractVariable.
	&quot;than index is incremented by one&quot;
	self varIndex: self varIndex + 1</code></pre><figcaption></figcaption></figure></p>
<p>All other actions are implemented in similar way. 
Also <em>MatchPanel</em> has an instance variable <code>varNames</code> which represents a collection of all metavariables that are currently present in rewrite rule. 
This variable helps to ensure, that transform part of rewrite rule (i.e. right hand side) uses only already existing metavariables. 
As use of non existing metavariables in right hand side of rewrite rule would lead to an error. 
More information about usage of <code>varNames</code> instance variable is given in next section about <em>TransformPanel</em> class. </p>
<p>Methods of <em>MatchPanel</em> class:</p>
<p>1. <strong><code>#isReplaceAvailableFor:</code></strong> returns a boolean, which says if it is possible to replace aNode (an argument of this method), 
or it should be reassigned.</p>
<p>2. <strong><code>#addChanges</code></strong> any action that changes AST of instance of <em>MatchPanel</em> class, 
is recorded into instance variable <code>undoDict</code> of instance of <em>TransformationRule</em> class. 
Generally, <code>undoDict</code> is a collection of all changes made with <em>MatchPanel</em> and/or <em>TransformPanel</em>. </p>
<p>3. <strong><code>#updateVarNames</code></strong> updates <code>varNames</code> instance variable, so it holds only existing metavariables in <em>MatchPanel</em>. </p>
<p>4. <strong><code>#updateTransformPanelFor:</code></strong> does a pass on AST that is held by <em>TransformPanel</em>. 
Replaces all nodes, that are equal to node that previous action in <em>MatchPanel</em> was applied, in <em>TransformPanel</em> with a new metavariable node. 
Than the displayed text and AST of <em>TransformPanel</em> are updated. 
For example, we have this code in <em>MatchPanel</em>:</p>
<p><figure><pre><code class="smalltalk">	super foo.
	`@variable1 doSomething</code></pre><figcaption></figcaption></figure></p>
<p>and following code in <em>TransformPanel</em>:</p>
<p><figure><pre><code class="smalltalk">	`@variable1 foo.
	`@variable1 bar</code></pre><figcaption></figcaption></figure></p>
<p>If user applies <em>Recurse into</em> action to <code>`@variable1</code> in <em>MatchPanel</em>, as a result <em>TransformPanel</em> will show next code:</p>
<p><figure><pre><code class="smalltalk">	``@variable1 foo.
	``@variable1 bar</code></pre><figcaption></figcaption></figure></p>
<p>5. <strong><code>#updateNextPanelForNode:</code></strong> is invoked after the current panel is updated in method <code>#updateInfoFor:withOld:andNew:</code>. 
First of all, this method updates <code>varNames</code> instance variable. 
After this, <em>TransformPanel</em> itself is updated via <code>#updateTransformPanelFor:</code> method. 
Than, <code>statusBar</code> color and information text are updated. 
<code>statusBar</code> instance variable is explained later. 
In the end, <code>#updateNextPanelForNode:</code> is invoked for <em>TransformPanel</em>, so the <em>ResultPanel</em> is updated. </p>
<h4>I.6.E. TransformPanel class</h4>
<p><em>TransformPanel</em> class is a subclass of <em>AbstractPanel</em>, instance of which holds transforming part of rewrite rule (i.e. right hand side part of rule). 
In <em>TransformPanel</em> not all options are available. For example, you can not <em>Recurse into</em>,
 due to the fact that metavariable that you are about to create does not exist. </p>
<p>Methods of <em>TransformPanel</em> class:</p>
<p>1. <strong><code>#menuActions</code></strong> removes all unavailable uptions from <em>TransformPanel</em> menu via <code>#removeUnavailableOptions:</code> method. </p>
<p>2. <strong><code>#removeUnavailableOptions:</code></strong> removes such options as <em>As list</em>, <em>Recurse into</em> and <em>Undo on node</em>. </p>
<p>3. <strong><code>#addOldNodes:</code></strong> updating information about <code>oldNodes</code> for each node in AST of <em>TransformPanel</em>. 
<code>oldNodes</code> propery of AST holds all nodes that where replaced up to the current node. </p>
<p>4. <strong><code>#chooseMetavariablesForNode:</code></strong> when user applies action such as <em>Abstract variable</em> in <em>TransformPanel</em> window is opened. 
In this window user can choose one of available metavariables to replace current node with it. </p>
<p>5. <strong><code>#chooseTempsForNode:</code></strong> same as <code>#chooseMetavariablesForNode:</code>, but is used when <em>Abstract temporaries list</em> action is invoked. </p>
<p>6. <strong><code>#updateNextPanelForNode:</code></strong> applies rewrite rule from <em>MatchPanel</em> and <em>TransformPanel</em> to AST of <em>SourcePanel</em>. 
As a result we have new AST. Code of this AST is displayed in <em>ResultPanel</em>.</p>
<h4>I.6.F. TransformationRule class</h4>
<p><em>TransformationRule</em> is model that represents bottom part of Builder. 
It contains <em>MatchPanel</em>, <em>TransformPanel</em> all buttons (undo, redo, generate rule, browse rules). 
Plus it has <code>undoDict</code> and <code>redoDict</code> instance variables. 
This variables are collections of instances of <em>RewriteRuleChange</em> class. 
Each change, that is made in one of three editable panel of Builder is recorded in <code>undoDict</code>. 
Obviously, <code>undoDict</code> instance variable is used in implementation of <code>#undo</code> action. 
When undoing a change, it is removed from <code>undoDict</code> and added to <code>redoDict</code>, which is used for implementation of <code>#redo</code> action. 
For example, if code was edited in <em>SourcePanel</em> manually, than <em>RewriteRuleChange</em> is added to <code>undoDict</code> as follows: </p>
<p><figure><pre><code class="smalltalk">	&quot;obviously, transformationRule , sourcePanel andsourcePanel ast may be accessed some other way, but here it is not considered for easier explanation&quot;

	transformationRule 
		undoDict add:
		(RewriteRuleChange new
		panel: sourcePanel asOrderedCollection;
		ast: (sourcePanel ast) asOrderedCollection;
		yourself)</code></pre><figcaption></figcaption></figure></p>
<p>Another example is, if user applies <em>Abstract variable</em> action to <code>self</code> variable in next code in <em>MatchPanel</em>: </p>
<p><figure><pre><code class="smalltalk">	self foo.
	^ self</code></pre><figcaption></figcaption></figure></p>
<p>when in <em>TransformPanel</em> we have:</p>
<p><figure><pre><code class="smalltalk">	super bar.
	self doSomething.
	^ self</code></pre><figcaption></figcaption></figure></p>
<p>Than, as a result to <code>undoDict</code> will be added following <em>RewriteRuleChange</em> instance:</p>
<p><figure><pre><code class="smalltalk">	RewriteRuleChange new
	panel: { matchPanel. transformPanel } asOrderedCollection;
	ast: { matchPanel ast. transformPanel ast } asOrderedCollection;
	yourself	</code></pre><figcaption></figcaption></figure></p>
<p>To understand why we added two panel and two ast to <em>RewriteRuleChange</em>, let us take a look at what has happened in Builder. </p>
<p><figure><pre><code class="smalltalk">	&quot;MatchPanel code&quot;
	`variable1 foo.
	^ `variable1

	&quot;TransformPanel code&quot;
	super bar.
	`variable1 doSomething.
	^ `variable1</code></pre><figcaption></figcaption></figure></p>
<p>As you see, both panels have changed at the same time, so this changes are considered as one. 
Thus, these changes are added to <code>undoDict</code> as one. </p>
<p>Methods of <em>TransformationRule</em> class: </p>
<p>1. <strong><code>#addChangeForPanel:</code></strong> adds a change to <code>undoDict</code>. 
Change is initialized with panel, passed to this method, and its AST. </p>
<p>2. <strong><code>#browseRules</code></strong> opens up Browser. </p>
<p>3. <strong><code>#generateRewriteRuleClass</code></strong> basically it generates new subclass of RBTransformationRule. 
This class is stored in a <em>RewriteRulesCustom</em> category. 
Also it has only one method - <code>#initialize</code>. 
Code of this method is generated by <code>#getRuleInitString</code> method, which is explained next. 
The name of class is specified by user, initially it is <em>MyRule</em>. </p>
<p>4. <strong><code>#getRuleInitString</code></strong> forms and returns a string, that is a code of <code>#initialize</code> method of <em>RBTransformationRule</em> subclass. </p>
<p>5. <strong><code>#matchPanelChanged</code></strong> is invoked when text in <em>MatchPanel</em> is accepted. 
First of all, it adds change made in <em>MatchPanel</em> to <code>undoDict</code> and enables <code>undoButton</code>. 
Also it updates AST and displayed text of <em>MathcPanel</em>. 
Than it updates information related to <code>statusBar</code> - color and text. 
<code>statusBar</code> is an instance variable of <em>RewriteRuleBuilder</em> class (or just Builder). 
In the end, the <em>ResultPanel</em> info is updated. </p>
<p>6. <strong><code>#transformPanelChanged</code></strong> is similar to <code>#matchPanelChanged</code> method, but does not update information about <code>statusBar</code>. 
It is invoked when text in <em>TransformPanel</em> is accepted. 
First of all, it adds change made in <em>TransformPanel</em> to <code>undoDict</code> and enables <code>undoButton</code>. 
Also it updates AST and displayed text of <em>MathcPanel</em>. 
In the end, the <em>ResultPanel</em> info is updated. </p>
<p>7. <strong><code>#undo</code></strong> reverts last change made in either <em>SourcePanel</em>, <em>MatchPanel</em> or <em>TransformPanel</em>, and removes this change from <code>undoDict</code>. 
Also it adds just undone change to <code>redoDict</code>. 
Next it updates displayed text and AST for each panel where changes were reverted. 
Finally the <code>#updateAfterUndoOrRedo</code> method is invoked. </p>
<p>8. <strong><code>#redo</code></strong> does undone change again to each panel influenced by <code>#undo</code>. 
Also it adds just redone change to <code>undoDict</code>. 
Next it updates displayed text and AST for each panel where changes were reverted. 
Finally the <code>#updateAfterUndoOrRedo</code> method is invoked. </p>
<p><strong>Note:</strong> as we see from two previous methods, that <code>#undo</code> and <code>#redo</code> can be done infinit number of times. </p>
<p>9. <strong><code>#ruleLabel</code></strong>  is an instance of <em>StringMorph</em>, that is displayed above <em>MatchPanel</em> and <em>TransformPanel</em>.  </p>
<p>10. <strong><code>#statusBarForRule</code></strong> returns an arrow that is placed between <em>MatchPanel</em> and <em>TransformPanel</em>. </p>
<p>11. <strong><code>#updateAfterUndoOrRedo</code></strong> enables or disables undo and redo buttons. 
Also updates text and color for <code>statusBar</code> instance variable of <em>RewriteRuleBuilder</em>. 
In the end, <em>ResultPanel</em> code is updated, as rewrite rule may have changed. </p>
<p>12. <strong><code>updateUndoDictFor:</code></strong> adds a change to <code>undoDict</code>. </p>
<p>13. <strong><code>updateRedoDictFor:</code></strong> adds a change to <code>redoDict</code>. </p>
<p>Class side:</p>
<p>14. <strong><code>#arrowMorph:</code></strong> is an instance of <em>PolygonMorph</em> or <em>ActivePolygonMorph</em>. 
It is shaped in form of arrow. </p>
<p>15. <strong><code>#defaultSpec</code></strong> creates a layout for all components. </p>
<h4>I.6.G. RRTextModel class</h4>
<p><em>RRTextModel</em> is a subclass of TextModel. It has some features that are needed for RewriteRuleBuilder, like AST and support of custom menu. 
Instances of <em>RRTextModel</em> are used in each of four panels: <em>SourcePanel</em>, <em>MatchPanel</em>, <em>TransformPanel</em>, <em>ResultPanel</em>. 
Each panel stores instance of this class in <code>textModel</code> instance variable. 
<code>textModel</code> stores AST and gives acces to custom menu, which can be invoked by right clicking on panel. </p>
<p>Methods of <em>RRTextModel</em> class:</p>
<p>1. <strong><code>#actionsForSelection</code></strong> performs <code>#menuOptions</code> for panel that is storet in <code>model</code> instance variable. 
<code>#menuOptionsSelector</code> fills right click menu with all available actions for selected node. </p>
<p>2. <strong><code>#getSelectedNode</code></strong> returns node, which is currently selected in <code>textModel</code>. </p>
<p>3. <strong><code>#codePaneMenu:shifted:</code></strong> forms a menu due to <code>#actionsForSelection</code> method. </p>
<h4>I.6.H. RewriteRuleChange class</h4>
<p><em>RewriteRuleChange</em> is class that holds changes that were made in Builder panels. 
Instances of this class are stored in collection - the instance variable <code>undoDict</code> of <em>TransformationRule</em>. 
The implementation of this class is very simple: it has only two instance variables - <code>panel</code> and <code>ast</code>. 
<code>panel</code> is one of four panels of Builder, and <code>ast</code> is an AST of this panel. </p>
<h4>I.6.I. ActivePolygonMorph class</h4>
<p><em>ActivePolygonMorph</em> is a subclass of <em>PolygonMorph</em>, that adds new functionality to <em>PolygonMorph</em>. 
It recognizes two events: <code>#mouseEnter:</code> and <code>#mouseLeave:</code>. 
Also it has <code>infoText</code> instance variable, which contains text information,
 that says if AST of <em>SourcePanel</em> matches left hand side rule part (AST of <em>MatchPanel</em>) or not. </p>
<p>Methods of <em>ActivePolygonMorph</em> class:</p>
<p>1. <strong><code>#infoMorph</code></strong> constructs morph, which is a <em>BorderedMorph</em> with <em>StringMorph</em> submorph. 
Contents of <em>StringMorph</em> is assigned to <code>infoText</code> instance variable, that is described before. </p>
<p>2. <strong><code>#mouseEnter:</code></strong> adds to self a submorph, that was created in <code>#infoMorph</code> method. </p>
<p>3. <strong><code>#mouseLeave:</code></strong> removes from self a submorph, that was created in <code>#infoMorph</code> method. </p>
<p>4. <strong><code>#handlesMouseOver:</code></strong> states that <em>ActivePolygonMorph</em> handles mouse over events, as it returns <code>true</code>. </p>
<h4>I.6.J. RewriteRuleBuilder class</h4>
<p>Is a class that represents a Builder as one complete object. 
<em>RewriteRuleBuilder</em> contains <em>SourcePanel</em>, <em>ResultPanel</em> and the most important part of Builder instance of <em>TransformationRule</em> class. 
This class is responsible for GUI and layouting all elements of Builder. 
Also it holds labels that are displayed in Builder. </p>
<p><code>statusBar</code> instance variable is an <em>ActivePolygonMorph</em> that shows if AST of <em>SourcePanel</em> matches AST of <em>MatchPanel</em>. 
Firstly, its color is green or red, which, clearly, depends on matching. 
This color is returned by <code>#matchColor</code> method. 
Secondly, when mouse is over it, the <em>StringMorph</em> shows up with text from <code>#matchLabel</code>. </p>
<p>Methods of <em>RewriteRuleBuilder</em> class:</p>
<p>1. <strong><code>#matchLabel</code></strong> returns a string that says if AST of <em>SourcePanel</em> matches AST of <em>MatchPanel</em> or not. </p>
<p>2. <strong><code>#resultLabel</code></strong> returns an information string for indicating a <em>ResultPanel</em>. </p>
<p>3. <strong><code>#rules</code></strong> is a collection of all subclasses of <em>RBTransformationRule</em> class. </p>
<p>4. <strong><code>#matchColor</code></strong> returns green or red color for <code>statusBar</code>. </p>
<p>5. <strong><code>#sourcePanelChanged</code></strong> is invoked when text is accepted in <em>SourcePanel</em>. 
It adds a change, that was made and accepted, to <code>undoDict</code> and enables undo button. 
Also updates displayed text and AST of <em>SourcePanel</em>. 
After that, it assigns right color and text to <code>statusBar</code> properies. 
Finally, this method updates code of <em>ResultPanel</em>. </p>
<p>6. <strong><code>#code:</code></strong> assigns a string to <code>code</code> of each panel in Builder. </p>
<p>7. <strong><code>#statusBarForMatch</code></strong> is a method used to initialize <code>statusBar</code> instance variable. 
Basically, it returns an instance of <em>ActivePolygonMorph</em> <code>#asSpecAdapter</code>, so it can be used in GUI built with Spec. </p>
<p>8. <strong><code>#statusBarForResult</code></strong> returns an instance of <em>ActivePolygonMorph</em> <code>#asSpecAdapter</code>. 
This morph is used to indicate <em>ResultPanel</em>. 
When mouse is over, shows a label with <code>#resultLabel</code> text. </p>
<p>9. <strong><code>#isMatching</code></strong> returns a boolean, that is <code>true</code> when AST of <em>SourcePanel</em> matches AST of <em>MatchPanel</em>, and <code>false</code> when it does not. </p>
<p>Class side: </p>
<p>10. <strong><code>#withCode:</code></strong> creates an instance of <em>RewriteRuleBuilder</em>. 
Each panel <code>code</code> is initiialized with a string that is passed as an argument. </p>
<p>11. <strong><code>#defaultSpec</code></strong> creates a layout for all components. </p>
<p>12. <strong><code>#menuCommandOn:</code></strong> adds Builder to a world menu under <em>Tools</em> tab. </p>
<p>13. <strong><code>#shiftedSourceCodeMenu:</code></strong> adds Builder to a Nautilus context menu under <em>Source code refactoring</em> tab. 
Each panel <code>code</code> instance variable in Builder is initialized with selected code in Nautilus. </p>
<h4>I.6.K. Command class</h4>
<p>A <em>Command</em> abstract class and its subclasses are implemented similar to Command pattern. 
However there are differences between this implementation and conventional one. 
Despite this fact, <em>Command</em> class has instance variable <code>commandReceiver</code> which is a reciever of action that should be performed. 
<code>commandReceiver</code> is a node of AST of panel. 
Another important element of <em>Command</em> class is <code>#execute</code> method. 
It is a generic method that is hard-coded for each subclass of <em>Command</em> class. 
Therefore for each action in Command pattern there is implemented one specific subclass of <em>Command</em> class with its own <code>#execute</code> method. 
<code>panel</code> instance variable presents <em>MatchPanel</em> or <em>TransformPanel</em>. 
It depends on to which panel <code>commandReceiver</code> belongs. </p>
<p>Methods of <em>Command</em> class: </p>
<p>1. <strong><code>#execute</code></strong> is responsible for executing an action. 
Each subclass must implement this method. </p>
<p>2. <strong><code>#change:For:</code></strong> replaces first argument for second. Both arguments are nodes of AST. 
So for replacement this method uses either assignement or <code>#replaceWith:</code> method. </p>
<p>3. <strong><code>#changeCommandReceiverFor:</code></strong> uses <code>#change:For:</code> method with a first argument <code>commandReceiver</code>. </p>
<p>Class side: </p>
<p>4. <strong><code>#receiver:panel:index:withSource:</code></strong> creates new instance of <em>Command</em> class initialized using arguments. </p>
<p>5. <strong><code>#isAccepted:</code></strong> returns <code>true</code>, explained in subclasses. </p>
<p>6. <strong><code>#isSequenceNeeded</code></strong> returns <code>false</code>, explained in subclasses. </p>
<h4>I.6.L. AbstractCommand class </h4>
<p><em>AbstractCommand</em> class implements common functionality for actions (commands) which, 
in result, create new metavariable. </p>
<p>Methods of <em>AbstractCommand</em> class: </p>
<p>1. <strong><code>#abstractName</code></strong> is a name of metavariable, that may be created with specific command. 
Each subclass must implement this method. </p>
<p>2. <strong><code>#length</code></strong> returns length of metavariable name, that may be created with specific command. </p>
<p>3. <strong><code>#abstractWithName:andIndex:</code></strong> creates metavariable named <code>#abstractName</code>. 
Than replaces <code>commandReceiver</code> with this metavariable.</p>
<p>Each subclass of this class implements <strong><code>#execute</code></strong> method almos identically to each other. </p>
<p><figure><pre><code class="smalltalk">	execute
		^ self abstractWithName: self abstractName andIndex: self panel &quot;someIndex&quot;</code></pre><figcaption></figcaption></figure></p>
<p>Basically, it invokes <code>#abstractWithName:andIndex:</code> method, and as arguments passes: 
1) its <code>#abstractName</code>;
2) index of specific metavariable type (it may be block, variable, statement, etc.)</p>
<p>You can see which metavariable is created in <code>#abstractName</code> method. 
For example, <em>AbstractBlockCommand</em> creates <code>`@block</code> metavariable. 
Thus, The Rewrite Engine will match any block. </p>
<p><em>RenameCommand</em> class works exactly like rename refactoring, 
but with this class you can rename/change any node, not just variable. </p>
    </div>

    <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
    <script src="https://code.jquery.com/jquery.js"></script>
    <!-- Include all compiled plugins (below), or include individual files as needed -->
    <script src="../_support/html/js/bootstrap.min.js"></script>

    <!-- Syntax highlighting of code blocks -->
    <script>hljs.initHighlightingOnLoad();</script>

  </body>
</html>
