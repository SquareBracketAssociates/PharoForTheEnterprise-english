!Persisting Objects with Voyage


Voyage is a small persistence framework developed by Esteban Lorenzano, constructed as a small layer between the objects and a persistency mechanism. It is purely object-oriented and has as a goal to present a minimal API to most common development usages. Voyage is a common layer for different backends but currently it supports just two: an ''in-memory'' layer and a backend for the MongoDB database (*http://mongodb.org>http://mongodb.org/*).

The in-memory layer is useful to prototype applications quickly and for initial development without a database back-end, for example using the Smalltalk image as the persistency mechanism. It is fully functional except for the ability to use database queries to retrieve a specific selection of objects.  

The MongoDB database backend stores the objects into MongoDB: a document-oriented database. In MongoDB each stored entity is a JSON-style document. This document-centric nature allows for persisting complex object models in a fairly straightforward fashion. MongoDB is not an object database, like Gemstone, Magma or Omnibase, so there still is a small gap to be bridged between objects and documents. To achieve this, Voyage contains an Object-Document mapper, i.e. the document database equivalent to an Object-Relational Mapper or ORM. While this mapper does not solve all the known impedance mismatch issues when going from objects to a database, we find that using a document database fits better with the object world than a combination of a ORM and a relational database. This is because document databases tend to provide better support for the dynamic nature of the object world.

Voyage provides a default way in which objects are stored in the database. Fine-grained configuration of this can be performed using Magritte descriptions. Voyage also includes a query API, which allows specific objects to be retrieved from a MongoDB database. We will discuss each of these features in this text. 


!! Setup

!!! Load Voyage

To install Voyage, including support for the MongoDB database, go to the Configurations Browser (in the World Menu/Tools) and load ConfigurationOfVoyageMongo. Or alternatively execute in a workspace:

[[[
Gofer it
	url: 'http://smalltalkhub.com/mc/estebanlm/Voyage/main';
	package: 'ConfigurationOfVoyageMongo';
	load.
(Smalltalk at: #ConfigurationOfVoyageMongo) load.
]]]

This will load all that is needed to persist your object models into a Mongo database.

!!! Install MongoDB 

Next is to install the MongoDB database. How to do this depends on your operating system, and is outside of the scope of this text. We refer to the MongoDB website *mongodb.org>http://www.mongodb.org/downloads* for more information.

!!! Create a repository

In Voyage, all persistent objects are stored in a repository. The kind of repository that is used determines the storage backend for the objects. 

To use the in-memory layer for Voyage, an instance of ==VOMemoryRepository== needs to be created, as follows:

[[[
repository := VOMemoryRepository new
]]]

In this text, we shall however use the MongoDB backend. To start a new MongoDB repository or connect to an existing repository create an instance of ==VOMongoRepository==, giving as parameters the hostname and database name. For example, to connect to the database ==databaseName== on the host ==mongo.db.url== execute the following code:

[[[
repository := VOMongoRepository 
	host: 'mongo.db.url' 
	database: 'databaseName'.
]]]

Alternatively, the port to connect to is specified by using the message ==host:port:database:==. Lastly, if authentication is required, the message ==host:database:username:password:== or ==host:port:database:username:password:== needs to be used.

!!! Singleton Mode and Instance Mode

Voyage can work in two different modes:

- Singleton mode: There is an unique repository in your image, which works as a singleton keeping all the data. When you use this mode, you can program using a "behavioral complete" approach where your instances respond to a certain vocabulary (see below for more details about vocabulary and usage).
- Instance mode: You can have an undetermined number of repositories living in your image. Of course, this mode requires you to make explicit which repositories you are going to use.


By default, Voyage works in instance mode: the returned instance has to be passed as an argument to all database API operations. Instead of having to keep this instance around, a convenient alternative is to use Singleton mode. Singleton mode removes the need to pass the repository as an argument to all database operations. To use Singleton mode, execute:

[[[
repository enableSingleton.
]]]

@@note Pay attention: Only one repository can be the singleton, hence executing this line will remove any other existing repositories from Singleton mode!

@@note In this document, we are going to cover Voyage in Singleton mode, but using it in Instance mode is straightforward as well. See the ==VORepository== persistence protocol for more information.

!!! Voyage API 

@@todo TODO Update the API with the newly revealed methods. See VOMongoRepository persistence protocol

The following two tables show the complete API of Voyage. These methods are defined on ==Object==, but will only truly do work if the receiver of the message is a Voyage root. In the remainder of this document we will discuss the majority of these methods.

First we show Singleton mode:

||save || stores an object into repository (insert or update)	
||remove || removes an object from repository	
||removeAll ||removes all objects of class from repository	
||selectAll ||retrieves all objects of some kind
||selectOne: ||retrieves first object that matches the argument
||selectMany: || retrieves all objects that matches the argument

Second is Instance mode. In Instance mode, the first argument is always the repository on which to perform the operation.

||save:|| stores an object into repository (insert or update)	
||remove: ||removes an object from repository	
||removeAll: ||removes all objects of class from repository	
||selectAll: ||retrieves all objects of some kind
||selectOne:where: ||retrieves first object that matches the where clause	
||selectMany:where: || retrieves all objects that matches the where clause

!!! Resetting or dropping the database connection

In a deployed application, there should be no need to close or reset the connection to the database. Also, Voyage re-establishes the connection when the image is closed and later reopened.

However, when developing, resetting the connection to the database may be needed to reflect changes. This is foremost required when changing storage options of the database (see the *enhancing* Enhancing Storage section). Performing a reset is achieved as follows:

[[[
VORepository current reset.
]]]

In case the connection to the database needs to be dropped, this is performed as follows:

[[[
VORepository setRepository: nil.
]]]

!!Storing objects

To store objects, the class of the object needs to be declared as being a ''root of the repository''. All repository roots are points of entry to the database. Voyage stores more than just objects that contain literals. Complete trees of objects can be stored with Voyage as well, and this is done transparently. In other words, there is no need for a special treatment to store trees of objects. However, when a graph of objects is stored, care must be taken to break loops. In this section we discuss such basic storage of objects, and in the next section on Enhancing Storage *enhancing* we show how to enhance and/or modify the way objects are persisted.

!!!Basic storage

Let's say we want to store an Association (i.e. a pair of objects). To do this, we need to declare that the class ==Association== is storable as a root of our repository.  To express this we define the class method ==isVoyageRoot== to return true.

[[[
Association class>>isVoyageRoot
	^true
]]]	

Then, to save an association, we need to just send it the ==save== message:

[[[
anAssociation := #answer->42.
anAssociation save.
]]]

This will generate a collection in the database containing a document of the following structure.

[[[
{ 
	"_id" : ObjectId("a05feb630000000000000000"), 
	"#instanceOf" : "Association", 
	"#version" : NumberLong("3515916499"), 
	"key" : 'answer', 
	"value" : 42
}
]]]

The collection in the database will be named ''association'', for the name of the root class. By default, Voyage creates a MongoDB collection for each root class.

The stored data keeps some ''extra information'' to allow the object to be correctly reconstructed when loading:

- ==instanceOf== records the Class of the stored instance. The collection can also contain subclasses of the class that was declared as a Voyage root, so to properly reconstruct instances the reference to the class is needed.
- ==version== keeps a marker of the version of the object that is committed. This property is used internally by Voyage for refreshing cached data in the application. Without a ==version== field the application would always refresh the object with the data from the database, losing a lot of performance).

Note that the documents generated by Voyage are not directly visible using Voyage itself, as the goal of Voyage is to abstract away from the document structure. To see the actual documents you need to access the database directly. For MongoDB this can be done through the ==mongo== command line interface, or a GUI tool such as RoboMongo (Multi-Platform) MongoHub (for Mac), or RockMongo (in php).

!!!Embedding objects
In general, objects are not so simple as associations of literals, but more complex, containing other complex object instances inside, leading to a tree of objects. We show now how these can be stored.

For example, let's say that we want to store rectangles and that each rectangle contains two points. To achieve this, we specify that the ==Rectangle== class is a document root:

[[[
Rectangle class>>isVoyageRoot
	^true
]]]

This allows rectangles to be saved to the database, for example as shown by this snippet:

[[[
aRectangle := 42@1 corner: 10@20.
aRectangle save.
]]]

This will add a document to the database with this structure:

[[[
{ 
	"_id" : ObjectId("ef72b5810000000000000000"), 
	"#instanceOf" : "Rectangle", 
	"#version" : NumberLong("2460645040"), 
	"origin" : { 
		"#instanceOf" : "Point", 
		"x" : 42, 
		"y" : 1 
	}, 
	"corner" : { 
		"#instanceOf" : "Point", 
		"x" : 10, 
		"y" : 20 
	}
}
]]]



!!!Referencing other roots
Sometimes the objects are trees that contain other root objects. For instance, you could want to keep users and roles as roots, i.e. in different collections, and a user has a collection of roles. If the embedded objects (the roles) are root objects, Voyage will store references to these objects instead of including them in the document.

Returning to our rectangle example, let's suppose we want to keep the points in a separate collection. In other words, now the points will be referenced instead of embedded.

After we add ==isVoyageRoot== to ==Point class==, and save the rectangle, in the collection ''rectangle'' we get the following document:

[[[
{ 
	"_id" : ObjectId("7c5e772b0000000000000000"), 
	"#instanceOf" : "Rectangle", 
	"#version" : 423858205, 
	"origin" : { 
		"#collection" : "point", 
		"#instanceOf" : "Point", 
		"__id" : ObjectId("7804c56c0000000000000000") 
	}, 
	"corner" : { 
		"#collection" : "point", 
		"#instanceOf" : "Point", 
		"__id" : ObjectId("2a731f310000000000000000") 
	} 
}
]]]

In addition to this, in the collection ''point'' we also get the two following entities:

[[[
{ 
	"_id" : ObjectId("7804c56c0000000000000000"), 
	"#version" : NumberLong("4212049275"), 
	"#instanceOf" : "Point", 
	"x" : 42, 
	"y" : 1 
}

{ 
	"_id" : ObjectId("2a731f310000000000000000"), 
	"#version" : 821387165, 
	"#instanceOf" : "Point", 
	"x" : 10, 
	"y" : 20 
}
]]]

!!! Breaking Cycles in Graphs

When the objects to be stored contain a graph of embedded objects instead of a tree, i.e. when there are cycles in the references that the embedded objects have between them, cycles between these embedded objects must be broken. If not, storing the objects will cause an infinite loop. The most straightforward solution is to declare one of the objects causing the cycle as a Voyage root. This effectively breaks the cycle at storage time, avoiding the infinite loop.

For example, in the rectangle example say we have a label inside the rectangle, and this label contains a piece of text. The text also keeps a reference to the label in which it is contained. In other words there is a cycle of references between the label and the text. This cycle must be broken in order to be able to persist the rectangle. To do this, either the label or the text must be declared as a Voyage root.

An alternative solution to break cycles, avoiding the declaration of new voyage roots, is to declare some fields of objects as transient and define how the graph must be reconstructed at load time. This will be discussed in the following section.

!! Enhancing Storage
@enhancing

You can change the way your objects are stored by adding Magritte descriptions to their classes. In this section, first we will talk about configuration options for the storage format of the objects, and then we will treat more advanced loading and saving of attributes, which can be used, e.g. to break cycles in embedded objects.

!!!Configuring Storage

Consider that, continuing with the rectangle example but using embedded points, we add the following storage requirements:

- We need to use a different collection named ''rectanglesForTest'' instead of ''rectangle''.
- We only store instances of the ==Rectangle== class in this collection, and therefore the ==instanceOf== information is redundant.
- The ==origin== and ==corner== attributes are always going to be points, so the ==instanceOf== information there is redundant as well.

We use Magritte descriptions with specific pragmas to declare properties of the container of the Mongo descriptions of that class (all Magritte descriptions are kept in containers) and to describe both the ==origin== and ==corner== attributes. 

The method ==mongoContainer== is defined as follows: First it uses the ==<mongoContainer>== pragma to state that it describes the container to be used for this class. Second it returns a specific ==VOMongoContainer== instance. This instance is configured such that it uses the ''retanglesForTest'' collection in the database, and that it will only store ==Rectangle== instances. Note that it is not required to specify both configuration lines. It is equally valid to only declare that the collection to be used is ''retanglesForTest'', or only specify that the collection contains just ==Rectangle== instances.

[[[
Rectangle class>>mongoContainer 
	<mongoContainer>
	
	^VOMongoContainer new 
		collectionName: 'rectanglesForTest';
		kind: Rectangle;
		yourself
]]]

The two other methods use the pragma ==<mongoDescription>== and return a Mongo description that is configured with their respective attribute name and kind, as follows: 

[[[
Rectangle class>>mongoOrigin
	<mongoDescription>

	^VOMongoToOneDescription new
		attributeName: 'origin';
		kind: Point;
		yourself
]]]

[[[
Rectangle class>>mongoCorner
	<mongoDescription>

	^VOMongoToOneDescription new
		attributeName: 'corner';
		kind: Point;
		yourself
]]]

A saved rectangle, now in the ''rectanglesForTest'' collection, will look more or less as follows:

[[[
{ 
	"_id" : ObjectId("ef72b5810000000000000000"), 
	"#version" : NumberLong("2460645040"), 
	"origin" : { 
		"x" : 42, 
		"y" : 1 
	}, 
	"corner" : { 
		"x" : 10, 
		"y" : 20 
	}
}
]]]

Other configuration options for attribute descriptions are:

- ==beEager== declares that the referenced instance is to be loaded eagerly (the default is lazy).
- ==beLazy== declares that referenced instances are loaded lazily.
- ==convertNullTo:== when retrieving an object whose value is Null (==nil==), instead return the result of evaluating the block passed as argument.

For attributes which are collections, the ==VOMongoToManyDescription== needs to be returned instead of the ==VOMongoToOneDescription==. All the above configuration options remain valid, and the ==kind:== configuration option is used to specify the kind of values the collection contains. ==VOMongoToManyDescription== provides a number of extra configuration options:

- ==kindCollection:== specifies the class of the collection that is contained in the attribute.
- ==convertNullToEmpty== when retrieving a collection whose value is Null (==nil==), it returns an empty collection.

!!!Custom Loading and Saving of Attributes

It is possible to write specific logic for transforming attributes of an object when written to the database, as well as when read from the database. This can be used, e.g., to break cycles in the object graph without needing to declare extra Voyage roots. To declare such custom logic, a ==MAPluggableAccessor== needs to be defined that contains Smalltalk blocks for reading the attribute from the object and writing it to the object. Note that the names of these accessors can be counter-intuitive: the ==read:== accessor defines the value that will be ''stored'' in the database, and the ==write:== accessor defines the transformation of this ''retrieved'' value to what is placed in the object. This is because the accessors are used by the Object-Document mapper when reading the object to store it to the database and when writing the object to memory, based on the values obtained from the database.

Defining accessors allows, for example, a ==Currency== object that is contained in an ==Amount== to be written to the database as its' three letter abbreviation (EUR, USD, CLP, ...). When loading this representation, it needs to be converted back into a Currency object, e.g. by instantiating a new Currency object. This is achieved as follows:

[[[
Amount class>>#mongoCurrency
        <mongoDescription>

        ^ VOMongoToOneDescription new
                attributeName: 'currency';
                accessor: (MAPluggableAccessor
                        read: [ :amt | amt currency abbreviation ]
                        write: [ :amt :value | amt currency: (Currency fromAbbreviation: value)]);
                yourself
]]]

Also, a post-load action can be defined for an attribute or for the containing object, by adding a ==postLoad:== action to the attribute descriptor or the container descriptor. This action is a one-parameter block, and will be executed after the object has been loaded into memory with as argument the object that was loaded.

Lastly, attributes can be excluded from storage (and hence retrieval) by returning a ==VOMongoTransientDescription== instance as the attribute descriptor. This allows to place cut-off points in the graph of objects that is being saved, i.e. when an object contains a reference to data that should not be persisted in the database. This may also be used to break cycles in the stored object graph. It however entails that when retrieving the graph from the database, attributes that contain these objects will be set to ==nil==. To address this, a post-load action can be specified for the attribute descriptor or the container descriptor, to set these attributes to the correct values.


!! Advanced querying
Voyage relies in MongoDB query language to perform its search requests, and therefore for Pharo they have the form of dictionaries (they are in fact JSON structures, but that does not change anything for us).
 
Most of the cases, we can simplify the query expressions by using MongoQueries, a package for transformation Pharo syntax into those sometimes annoying dictionaries. 

In the following, we cover some of the main problems that we have seen while performing complex queries.

!!!Sorting and limiting object retrieval

Voyage has a group of protocols to perform search that can be more or less mapped to regular collection protocols: 

- ""==selectAll=="" Retrieves all documents in the database.

- ""==selectOne:=="" Retrieves one document. This maps to a ==detect:== method.
@@note what is the argument? show an example

- ""==selectMany:=="" Retrieves many documents. This maps to a ==select:== method.
@@note what is the argument? show an example


@@note may be put an example here for the three queries


As it is said, you can understand these methods just like their equivalents in Collection protocols. But, unlike regular collections which can operate fully on memory, often Voyage collection queries need to be customized in order to optimize memory consumption and/or accessing speed (since there can be literally millions of documents in each collection). 
To perform this task better, we provide some protocols that extend the common operations:

- ""==selectAllSortBy:=="" It retrieves all documents from a collection, sorted by the information that you provide as a dictionary. 

[[[
Customer selectAllSortBy: { #name -> VOOrder ascending } asDictionary.
]]]

@@note esteban why this is not sortedBy?


This will answer all objects in ?? which collection?? collection in ascending order by its attribute 'name'.

@@note The class ==VOOrder== provides constants to pick ==ascending== or ==descending== sort order. 

- ""==selectMany: aBlock sortBy: aDictionary=="" Retrieves a collection of objects from mongo database filtered by an expression (a block) and sorted according to a dictionary mapping. 

[[[
Customer 
	selectMany: [ :each | each orders > 10 ] 
	sortBy: { #name -> VOOrder ascending } asDictionary.
]]]

@@note Esteban you should explain when we should pass a block and when a dictionary. This is unclear. And in addition 


- ""==selectMany: aBlock limit: anInteger=="" Retrieves a collection of objects from mongo database filtered by an expression. 

The collection size is restricted to the limit provided.
 
[[[
Customer 
	selectMany: [ :each | each orders > 10 ] 
	limit: 100
]]]

This is useful when you know that you are not going to use more than a certain amount of objects, or when you know that there is a large number of persistent objects and you do not want to push the environment to its limit.

- ""==selectMany: aBlock limit: anInteger offset: anInteger=="" Retrieves a collection of objects from mongo database filtered by an expression. The collection size is restricted to the limit provided.

The first object retrieved will be at the offset position plus one.

[[[
Customer 
	selectMany: [ :each | each orders > 10 ] 
	limit: 100
	offset: 100
]]]

This is especially useful when paginating objects. 

- ""==selectMany:sortBy:limit:offset:=="" Retrieves a collection of objects from mongo database filtered by an expression. The collection size is restricted to the limit provided. The first object retrieved will be at the offset position plus one.

The resulting collection will be sorted by the expression provided. In the example below the expression states that the result is sorted in increasing value of the name field.

[[[
Customer 
	selectMany: [ :each | each orders > 10 ]
	sortBy: { #name -> VOOrder ascending } asDictionary
	limit: 100
	offset: 100
]]]



!!! Using MongoQueries 
The easiest (and recommended when possible) way to query MongoDB database is by using the package MongoQueries. MongoQueries is not part of Voyage but an optional part of the  MongoTalk layer. 
MongoTalk provides all the low-level operations for accessing MongoDB. MongoQueries transforms, within certain restrictions, regular Pharo blocks into JSON queries in the form expected by the database. 

In essence, MongoQueries is a Domain Specific Language to create MongoDB queries. A mongo query looks like a regular Pharo expression, but is much more restricted than what you can actually do with plain Smalltalk.

Here is a list of the operators that are available in MongoQueries:

|Operand|Usage|
|<, <=, >, >=, =, ~=|Regular comparison operators, they work as usual|
|&|AND operator|
|{{{|}}}|OR operator|
|not|NOT operator|
|at:|Direct access to a field.|
|where:|Allows the execution of a $where mongo statement|
 
!!!!Using ==at:== message to access embedded documents
Since MongoDB stores documents of any complexity, it is very common that one document is composed by several embedded documents, something like this: 

[[[
{ 
	"origin" : { 
		"x" : 42, 
		"y" : 1 
	}, 
	"corner" : { 
		"x" : 10, 
		"y" : 20 
	}
}
]]]

In this case, if you want to select objects filtered by one of the embedded document elements, you need to use the message ""==at:=="", and the field separator """.""". 
If you want to select all the rectangles whose origin x value is equal to 42, you should write your query as follow. 

[[[
Rectangle selectMany: [ :each | (each at: 'origin.x') = 42 ]
]]]

!!!!Using ==where:== message to perform complex (in javascript) comparisons
Sometimes you need to perform queries which are outside the capabilities of MongoQueries or even the JSON MongoDB Query Language. To overcome this problem, MongoDB provides a way to write your queries directly in JavaScript, by using the ==$where== operand. 
With MongoQueries, we can use the same by sending the ==where:== message:

In the following example, we use the JavaScript expression =='this.origin.x \== 42'==.
[[[
Rectangle selectMany: [ :each | each where: 'this.origin.x == 42' ].
]]]

You can see a more accurate documentation about the use of ==$where== in *MongoDB where documentation>http://docs.mongodb.org/manual/reference/operator/where/#op._S_where*.


!!!Using JSON queries

MongoQueries is very powerful and most of the time you will not need to use anything else. Nevertheless, there are some situations that require a deeper control of what you request. 

For that, we can always create a JSON query. JSON queries are the MongDB query internal representation, and we have a really easy way of taking advantage of it. In a nutshell, a JSON structure is a dictionary with pairs formed by a string and a value who can be a primitive value, a collection or another JSON structure (another dictionary). We can create a dictionary that acts as a query for MongoDB. 

Let's see two examples expressing the same query, first using a block as offered by MongoQueries and second a JSON dictionary.

""MongoQueries version:""

[[[
[ :each | each name = 'John Doe']
]]]

""Dictionary query version:""

[[[
{ 'name' -> 'John Doe' } asDictionary
]]]

This is obviously the easiest query possible, but we can easily increase the complexity.
A dictionary pairs are composed following an AND semantics. The following example selects the elements having 'John Doe' has name and whose orders value is greater than 10. 

[[[
{ 
	'name' -> 'John Doe'.
	'orders' -> { '$gt' : 10 } asDictionary 
} asDictionary
]]]


As you can see, to construct the "greater than" statement, we added a new dictionary with the evaluation we want. As you also can see, the more complex our query, more dictionaries we will need to add.

Now to express an OR condition, we should create a dictionary whose key is =='$or'== and whose values
are the conditioned expressions. 
The following example show how to select all objects with last name is Doe and more than ten orders OR objects with last name is not Doe and has ten or less orders:

[[[
{ '$or' : 
	{
		{ 
			'name.lastName' -> 'Doe'.
			'orders' -> { '$gt': 10 } asDictionary 
		} asDictionary.
		{ 
			'name.lastName' -> { '$ne': 'Doe'} asDictionary.
			'orders' -> { '$lte': 10 } asDictionary 
		} asDictionary.
	}.
} asDictionary.
]]]

The previous example shows you the kind of complexity you can easily achieve. But we can do more. 
Imagine that you want to take all entries with last name starting with a letter "D". You then need a regexp to match your name attributes. For this you can use the Mongo expressions ==$regexp== and ==$options$== as follows: 
 
[[[
{
	'name.lastName' -> { 
		'$regexp': '^D.*'.
		'$options': 'i'.
	} asDictionary.
} asDictionary.
]]]

This illustrates clearly the power of JSON queries.  There is a lot of different queries you can construct. You can see a complete list of operators and usages in the *MongoDB operator documentation>http://docs.mongodb.org/manual/reference/operator*


!! Conclusion 

In this chapter we presented Voyage a simple but powerful layer to store documents. We focused on the Mongo back-end and show that the package MongoQueries supports many possibilities.


% Local Variables:
% eval: (flyspell-mode 1)
% End:
