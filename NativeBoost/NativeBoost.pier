! NativeBoost Recipes

There is nothing better than real examples to learn. In this chapter, we will create some bindings to X11 Xlib. This chapter was written by L. Laffont during a visit in the RMOD team and largely revisited by S. Ducasse. 


!! Some documentation

First, you may need some documentation:

- The Xlib documentation: http://www.x.org/docs/X11/xlib.pdf
- NativeBoost project on SmalltalkHub: http://www.smalltalkhub.com/#!/~Pharo/NativeBoost
- Language-side Foreign Function Interfaces with NativeBoost: http://hal.archives-ouvertes.fr/docs/00/84/07/81/PDF/paper.pdf


!! Must read before start!

Before doing anything we should check first that we can link with the library that we want to use, here X11. 


First, as the Pharo VM runs in 32-bit, the libraries you want to bind to (and their dependencies) must be compiled for 32-bit. Major Linux distributions provide 32-bit versions of their packages. For example, on ArchLinux 64-bit, when you search for ==libx11== package:

[[[
$ pacman -Ss libx11
extra/libx11 1.6.1-1 [installed: 1.6.0-1]
    X11 client-side library
multilib/lib32-libx11 1.6.1-1
    X11 client-side library (32-bit)
]]]

In order to create the bindings, we need to install the 32-bit package: 

[[[
pacman -S multilib/lib32-libx11
]]]

and the library will be found at ==/usr/lib32/libX11.so==.


Sometimes the library isn't available for 32-bit, so you will have to build it. Often libraries rely on autotools for the compilation and it's just a story of setting ==-m32== flags for ==gcc==. Here's the example for ==YAZ== library:

[[[
$ wget http://ftp.indexdata.dk/pub/yaz/yaz-4.2.63.tar.gz
$ tar -xvzf yaz-4.2.63.tar.gz
$ cd yaz-4.2.63
$ ./configure CFLAGS="-m32" LDFLAGS="-m32"
$ make
$ sudo make install
]]]

We can check that the library is 32-bit with the ==file== command. Here the output mention that the library is 32-bit which is compatible with the current implementation of NativeBoost and Pharo VM \footnote{There are plans to have a 64 bits version of the Pharo VM and as soon as this happens there will be a 64 bit version of NativeBoost.}.

[[[
$ file /usr/local/lib/libyaz.so.4.0.0 
/usr/local/lib/libyaz.so.4.0.0: ELF 32-bit LSB  shared object, Intel 80386, version 1 (SYSV), dynamically linked, BuildID[sha1]=479fbc7e495cb53600f145cf575dc1f176703c20, not stripped
]]]



We also have to be sure that all dependent libraries are found:

[[[
$ ldd /usr/local/lib/libyaz.so.4.0.0
        linux-gate.so.1 (0xf773a000)
        libgnutls.so.28 => /usr/lib32/libgnutls.so.28 (0xf745d000)
        libexslt.so.0 => not found
        libxslt.so.1 => /usr/lib32/libxslt.so.1 (0xf7417000)
]]]

Here ==libexslt.so.0== is not found, so we have to make sure it is present, 32-bit and on the right path. On the system I use, ==libexstl== has been installed on ==/usr/local/lib/== and I should either move them to ==/usr/lib32==, or set the environment variable ==LD_LIBRARY_PATH==.

[[[
$ export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/local/lib
$ ldd libyaz.so
        linux-gate.so.1 (0xf7728000)
        libgnutls.so.28 => /usr/lib32/libgnutls.so.28 (0xf744b000)
        libexslt.so.0 (0xf7434000)
]]]

To add a custom directory globally to ==LD_LIBRARY_PATH==, just add it in ==/etc/ld.so.conf==.

At last, remember that we can write bindings for C libraries easily, other languages such as ==C\+\+== are beyond the scope of this chapter.

!!! To install X11 on Mac
If you are on Mac OSX you can try one of the following way to install X11. Based on our experience, the last one seems more reliable. 
[[[
sudo port install xorg-libX11
sudo port -v install xorg-server
http://xquartz.macosforge.org/landing/
]]]

Once install open a new shell and type ==xeye&== you should get the famous eye application looking at you. 

Oh, do not forget to save your image quite often, a crash can easily occur if we make some mistake on this field!


!! A first NativeBoost binding

Before our program can use a display, we must establish a connection to the X server using ==XOpenDisplay==. 
Taking from the documentation: "==The XOpenDisplay()== function returns a Display structure that serves as the connection to the X server and that contains all the information about that X server. ==XOpenDisplay()== connects your application to the X server through TCP or DECnet communications protocols, or through some local inter-process communication protocol."

The signature in ==Xlib.h== (that you should find at ==/usr/include/X11/Xlib.h== or ==/usr/X11/include/X11== on Mac) is:

[[[
Display *XOpenDisplay(char *display_name);
]]]


First, we can check that Pharo and NativeBoost could load the Xlib library and find the function. In a workspace, inspect the result of:

[[[
self nbGetSymbolAddress: 'XOpenDisplay'  module: '/your/path/to/32-bit/libX11.so'
]]]

That should answer something like ==@ 16rF71D14D0==, the address of the function. If ==nil== is answered, then something is wrong and you should refer to previous section. Else, we can go further!


The function ==XOpenDisplay== takes a pointer on char as parameter (thus a String) and returns a pointer on a ==Display==. 
We could define all the function in a large class representing the library, but we will apply an object-oriented decomposition of the X11 world. Therefore,  we need to define a class that will hold an handle for ==Display==. We can do this by creating a subclass of ==NBExternalObject== as follows:

[[[
NBExternalObject subclass: #NBXLibDisplay
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'NBXLib'
]]]


For each NativeBoost entity we have to define the function ==#nbLibraryNameOrHandle== that answers the path to the module. In order to not define multiple times this function, we can define a ==Trait== to be used by all our ==NBXLib== package classes:

[[[
Trait named: #TNBXLibLibrary
	uses: {}
	category: 'NBXLib'

TNBXLibLibrary class>>nbLibraryNameOrHandle
	^ '/your/path/to/32-bit/libX11.so'

TNBXLibLibrary>>nbLibraryNameOrHandle
	^ self class nbLibraryNameOrHandle
]]]


Then we update the ==NBXLibDisplay== class definition to:

[[[
NBExternalObject subclass: #NBXLibDisplay
	uses: TNBXLibLibrary
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'NBXLib'
]]]


We can now create the binding for the function ==XOpenDisplay==. As it will be used to create a new ==NBXLibDisplay== instance, we should define the primitive on the class side:

[[[
NBXLibDisplay class>>open: displayName
	<primitive: #primitiveNativeCall module: #NativeBoostPlugin error: errorCode>
	^self nbCall: #(NBXLibDisplay XOpenDisplay (char * displayName))
]]]

Note that we specify in the signature that the function returns an ==NBXLibDisplay== (i.e., an instance of the class itself) while the C function mentioned a ==Display== type. NativeBoost is handling that for us. 


Then we can try to open the default X display (number 0):

[[[
NBXLibDisplay  open: ':0'
]]]

that should answer a new instance on ==NBXLibDisplay==. If ==displayName== argument is ==NULL==, XOpenDisplay defaults to the value of the ==DISPLAY== environment variable. As it's often what we want, we can add a new class method named ==open== defined as follows:

[[[
NBXLibDisplay class>>open

	<primitive: #primitiveNativeCall module: #NativeBoostPlugin error: errorCode>
	^self nbCall: #(NBXLibDisplay XOpenDisplay (nil))
]]]

and then we can open the default display with:

[[[
NBXLibDisplay open
]]]

When you inspect the result of the last expression you should obtain Figure

+Inspecing NBXLibDisplay open>file://figures/displayInstance.pdf|width=40|label=displayInstance+


!! About NativeBoostPlugin primitives
Now it is time to explain a bit what we did.

This line:

[[[
<primitive: #primitiveNativeCall module: #NativeBoostPlugin error: errorCode>
]]]

is called a ==pragma==. It indicates that the ==#primitiveNativeCall== of the ==#NativeBoostPlugin== should be called when this method is executed. If it fails, an ==errorCode== is returned and the  code below is executed. The pragma indicates to the system to execute the assembly code that was generated to perform a foreign call. If it fails the code ==nbCall:== is executed. 



[[[
^self nbCall: #(NBXLibDisplay XOpenDisplay (char * displayName))
]]]

The ==nbCall:== will parse the array and produces the adequate machine code to perform a function call. 



!!! Mapping C - Pharo

Now remember that the actual C signature is:

[[[
Display *XOpenDisplay(char *display_name);
]]]

Let us have a look at how NativeBoost maps C to Smalltalk and the inverse. The message ==nbCall:== parses the signature of the function to call as a literal array. NativeBoost automatically does the marshalling between C and Pharo, given a few rules.

First, in C you have these primitive types: ==int==, ==unsigned int==, == void *==  and so on. The NativeBoost parser ==NBFnSpecParser== actually handles single keyword type. So, instead of writing ==unsigned int==, we should use ==uint==. Here are some primitive types and their mapping to Pharo types. 
- uint or int: Integer
- bool: Boolean
- float: Float
- char: Character

See below for a longer list.

!!! About C strings

Usually the C idioms to represent a string datatype is to declare a pointer on a character and that the array containing characters is null terminated -- In C there is no such formal type definition of what string is. Now when we want to call functions expecting char ==x== care must be taken. Let us see why.

We should pay attention because  char ==*== data type is not a string. It means that a library could specify such type 
but in reality does not expect a string but simply a pointer. Therefore and read the documentation of the library to make sure
that function argument in the question is expecting a string and not just a pointer to char value.

For null terminated strings, NativeBoost provides special type named ==String==. Using this type, the value is automatically converted between a Smalltalk byteString and a C null-terminated string. 

When you know that your library is really expecting a C null terminated string, it is safer to use ==String== in a NativeBoost type declaration than ==char *== because char ==*== is just managed as a simple pointer to the beginning of string but does not make sure that the string is null-terminated.

So we can change ==NBXLibDisplay class>>open== to use ==String==:

[[[
^self nbCall: #(NBXLibDisplay XOpenDisplay (String displayName))
]]]


!!! Supported Types

Here is the list of types NativeBoost supports by default. 

!!!! Booleans
- bool NBBool

!!!! Fixed size integer types. Here the byte order is platform dependent. 
- int8 NBInt8
- uint8 NBUInt8
- int16 NBInt16
- uint16 NBUInt16
- int32 NBInt32
- uint32 NBUInt32
- int64 NBInt64
- uint64 NBUInt64

!!!! Aliases to common C compiler types.. some of them are platform dependent, some is not... because the C standard does not fully specify it

-		signedByte int8
-		unsignedByte int8
-		signedShort int16
-		unsignedShort uint16
-		signedChar int8  
-		unsignedChar uint8
-		schar int8
-		uchar uint8
-		signedLong int32
-		unsignedLong uint32
-		sbyte int8
-		byte uint8
-		short int16
-		ushort uint16
-		long int32
-		ulong uint32
-		longlong int64
-		ulonglong uint64
-		uint uint32
-		int int32

!!!! Unsigned for sizes.
Usually same size as platform's word size. It is unsigned integer types having the same length as a pointer. 
- size_t NBSizeT
		
!!!! Character type. 
-		Character NBCharacterType
-		char NBCharacterType
Note that Character and char are special. NativeBoost converts between C character and Pharo Character instances. 
If you just want to use unsigned integer value use ==uint8== or ==int8== instead (The 8 indicates that this is one byte). 
		

!!!! Floats fixed-size. 
Here again such type are platform-dependent byte order.

-		float16 NBFloat16
-		float32 NBFloat32
-		float64 NBFloat64
-		float128 NBFloat128

!!!! Floats common type names.
NativeBoost provides some aliases to C type names. 				
-		float float32
-		double float64
-		shortFloat float16







!!! Customizing Type Resolution

We can also affect the way NativeBoost resolves types. For example, we would like to keep the type ==Display== used in the C signature instead of writing ==NBXLibDisplay==. So we would like to write simply the following:

[[[
^self nbCall: #(Display XOpenDisplay (String displayName))
]]]


To know which class to use for the ==Display== type, NativeBoost looks up for the type in this order:
- class variable
- shared pool
- class

If we decide to use class variable, we can change the definition of ==NBXLibDisplay== to:

[[[
NBExternalObject subclass: #NBXLibDisplay
	uses: TNBXLibLibrary
	instanceVariableNames: ''
	classVariableNames: 'Display'
	poolDictionaries: ''
	category: 'NBXLib'
]]]

and then initialize the ==Display== class variable. Note that the value is a symbol because the array contains literal values.
Do not forget to evaluate ==NBXLibDisplay initialize== once you define the method:

[[[
NBXLibDisplay class>>initialize

	Display := #NBXLibDisplay
]]]


When we run again ==NBXLibDisplay open==, NativeBoost will map ==Display== return type to ==NBXLibDisplay== class.

As we often need to have these mapping across several classes in our package, it is best to use shared pools. We then define the shared pool ==NBXLibTypes== 
and define a class variable named ==Display== that we initialize correctly. Then all our code is:

[[[
Trait named: #TNBXLibLibrary
	uses: {}
	category: 'NBXLib'

TNBXLibLibrary class>>nbLibraryNameOrHandle
	^ '/your/path/to/32-bit/libX11.so'

TNBXLibLibrary>>nbLibraryNameOrHandle
	^ self class nbLibraryNameOrHandle

SharedPool subclass: #NBXLibTypes
	instanceVariableNames: ''
	classVariableNames: 'Display'
	poolDictionaries: ''
	category: 'NBXLib'

NBXLibTypes class>>initialize 

	Display := #NBXLibDisplay.
	
NBExternalObject subclass: #NBXLibDisplay
	uses: TNBXLibLibrary
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: 'NBXLibTypes'
	category: 'NBXLib'

NBXLibDisplay class>>open
	<primitive: #primitiveNativeCall module: #NativeBoostPlugin error: errorCode>
	^self nbCall: #(Display XOpenDisplay (nil))

NBXLibDisplay class>>open: displayName
	<primitive: #primitiveNativeCall module: #NativeBoostPlugin error: errorCode>
	^self nbCall: #(Display XOpenDisplay (String displayName))

]]]

!!! A word about NBExternalObject

Instances of ==NBExternalObject== represent an external object of one kind, provided by some external library/function. An instance holds a handle, which is used to identify the external object when this instance is passed as an argument, or when it is used as a return type in function signature.

A typical usage of ==NBExternalObject== is to create a subclass, and then use that subclass name directly in function signatures. This is what we did previously.

[[[
NBExternalObject subclass: #NBXLibDisplay

newObj := NBXLibDisplay newObject.

MyExternalObject class>>newObject
	<primitive: #primitiveNativeCall module: #NativeBoostPlugin error: errorCode>
	^self nbCall: #(Display XOpenDisplay (nil))
]]]

Here, we assume that ==XOpenDisplay()== returns some handle (or pointer) to some opaque external structure. Using a NBExternalObject' subclass (e.g., MyExternalObject) as a return type into the function signature, we are telling the code generator to automatically convert the return value into an instance of a given class and initialize its handle to the value returned by the function.

When used as argument type, the value, which is used to pass to the external function is a value held in the ==handle== instance variable.

The main advantage of using ==NBExternalObject== subclass as a type name for arguments is that it provides type safety by checking the incoming argument, that it
is an instance of your class, and nothing else. If not, the primitive will fail without calling the external function.


!! Self magic

To close the connection to a Xlib Display, we should use the C function:

[[[
int XCloseDisplay(Display *);
]]]


Since we are in Pharo, we would like to have an oriented-object API instead of defining all C functions on class side for example. So we would like to close the connection like this: ==myDisplay close==. Let's define an instance level method in the class ==NBXLibDisplay==:

[[[
NBXLibDisplay>>close
	<primitive: #primitiveNativeCall module: #NativeBoostPlugin>
	^self nbCall: #(int XCloseDisplay(Display self))
]]]

See how we use ==self== to refer to the object itself. Even more, with ==self== we can omit the type and just write:

[[[
NBXLibDisplay>>close
	<primitive: #primitiveNativeCall module: #NativeBoostPlugin>
	^self nbCall: #(int XCloseDisplay(self))
]]]

Now we can open and close the display:

[[[
| display |
display := NBXLibDisplay open.
display close.
]]]


!! Let's start the real fun stuff!

The goal of this section is to be able to find our desktop application windows and then to move or resize them. Each window has properties attached, called Atoms. Each Atom type has a unique identifier. When your window manager follows the ==Extended Window Manager Hints (EWMH)== spec (this is the case for Gnome and KDE, see http://standards.freedesktop.org/wm-spec/wm-spec-1.3.html), you can get all windows managed by the window manager using Xlib C function ==XGetWindowProperty== for the Atom ==_NET_CLIENT_LIST_STACKING==.


First we need to find the identifier of the Atom ==_NET_CLIENT_LIST_STACKING== using the Xlib function ==XInternAtom==:
[[[
Atom XInternAtom(Display* display, char* atom_name, Bool only_if_exists)
]]]


As we want to have a nice object-oriented API, we should separate the instance creation method and primitive on a new ==NXLibAtom== class. Let's start with the primitive. ==Atom== is defined in ==X.h== as:

[[[
typedef unsigned long Atom;
]]]

So we should add the definition of the Atom mapping to our shared pool:

[[[
NBXLibTypes class>>initialize 
	Display := #NBXLibDisplay.
	Atom := #ulong
]]]

and we should not forget to run ==NBXLibTypes initialize==.

Now we can define a method ==atomNamed: aString== using the ==XInternAtom== primitive:
 
[[[
NBXLibDisplay>>atomNamed: aString
	<primitive: #primitiveNativeCall module: #NativeBoostPlugin error: errorCode>
	^self nbCall: #(Atom XInternAtom(self, String aString, true))
]]]

Note that we define the method as an instance method since we will invoke it on an existing object representing the display. 
Here we give ==true== to the last argument so the Atom will be created if it does not exist. Note that for booleans we don't need to specify the type. You can check that this is working:

[[[
NBXLibDisplay open atomNamed: '_NET_CLIENT_LIST_STACKING' 
]]]

which answers ==460== on our machine (this changes for each display).


!!! Getting the root window

We need to get the root window of the display before querying any property on it, using the Xlib function:
[[[
Window XDefaultRootWindow(Display *display);
]]]

Since  ==Window== will be an external object we want to attach functions to, so let's define it as:

[[[
NBExternalObject subclass: #NBXLibWindow
	uses: TNBXLibLibrary
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: 'NBXLibTypes'
	category: 'NBXLib'
]]]

and update the shared pool (do not forget to run ==NBXLibTypes initialize==):
[[[
NBXLibTypes class>>initialize 
	Display := #NBXLibDisplay.
	Atom := #ulong.
	Window := #NBXLibWindow.
]]]

We can implement a method defined on the ==NBXLibDisplay== class to get the defaultRootWindow by calling the ==XDefaultRootWindow== function.
Now you should be able to define it by yourself without reading the following definition. We define it as follows:

[[[
NBXLibDisplay>>defaultRootWindow
	<primitive: #primitiveNativeCall module: #NativeBoostPlugin error: errorCode>
	^self nbCall: #(Window XDefaultRootWindow(self))
]]]

This code should answer a ==NBXLibWindow== instance:
[[[
NBXLibDisplay open defaultRootWindow
]]]


As Xlib functions often need to access the display and the window for window manipulations, we should update the code so that a ==NBXLibWindow== instance could reference its display. We add an instance variable ==display== to the NBXLibWindow class and defined accessor methods.

[[[
NBExternalObject subclass: #NBXLibWindow
	uses: TNBXLibLibrary
	instanceVariableNames: 'display'
	classVariableNames: ''
	poolDictionaries: 'NBXLibTypes'
	category: 'NBXLib'

NBXLibWindow>>display: aNBXLibDisplay
	display := aNBXLibDisplay

NBXLibWindow>>display
	^ display

]]]

Then we rename the previous ==defaultRootWindow== to ==primitiveDefaultRootWindow== and move it to the private protocol. Finally we define
a new method ==defautlRootWindow== as follows:


[[[
NBXLibDisplay>>defaultRootWindow
	^ self primDefaultRootWindow display: self ; yourself

NBXLibDisplay>>primDefaultRootWindow
	<primitive: #primitiveNativeCall module: #NativeBoostPlugin error: errorCode>
	^self nbCall: #(Window XDefaultRootWindow(self))


]]]

!!! Getting Properties 

Now the hard part. Xlib defines a generic function to get properties, ==XGetWindowProperty==. It is a bit verbose and its signature is:
[[[
int XGetWindowProperty (
  Display *display, 
  Window w, 
  Atom property, 
  long long_offset, 
  long long_length, 
  Bool delete, 
  Atom req_type,
  Atom * actual_type_return, 
  int * actual_format_return, 
  unsigned long * nitems_return, 
  unsigned long * bytes_after_return,
  unsigned char ** prop_return);
]]]

- The three first parameters are easy: the display, the root window in our case, and the Atom ==_NET_CLIENT_LIST_STACKING==. 
- For ==long_offset== and ==long_length==, they can be used to do a partial read of the properties. To get easy, we will get all, so ==0== for the offset and ==16rFFFF== for the length. So we don't care about ==bytes_after_return== in our case
- For the ==req_type==, we can use the Xlib constant ==AnyPropertyType== and don't care about ==actual_type_return== and ==actual_format_return== actually

The Atom ==AnyPropertyType== is a special Atom defined to 0. We can add it to the shared pool for later use:

[[[
NBXLibTypes class>>initialize 
	Display := #NBXLibDisplay.
	Atom := #ulong.
	AnyPropertyType := 0.
]]]


!!!! About returned values.

The last five arguments of the function ==XGetWindowProperty== are output parameters. They are used by the library to store
return values at the location that user must provide. This is why they are specified as pointers.

The first four we can use a ByteArray buffer that is big enough to hold the returned data. In our case this is 4 bytes each as we will show just after. The NativeBoost declaration for ==actual_type_return==, ==actual_format_return==, ==nitems_return==, ==bytes_after_return== is simply the following one: 

[[[
Atom * actualType,  int * actualFormat, ulong * nbItems, ulong * bytesAfterReturn
]]]

The last argument requires a bit more attention. 

!!! Dealing with char **

The ==prop_return==  is defined as ==unsigned char \*\*==, literally a pointer on a pointer on a character or a pointer on string. 
The idea is that this is a pointer that a library will use to give back a string: a pointer to the resulting string. To deal with such 
C idioms NativeBoost offers the notion of external address. Using and instance of the class ==NBExternalAddress== will hold an address.

Let's add the primitive that will retrieve the properties using the ==XgetWindowProperty== function.

[[[
NBXLibWindow>>primGetWindowProperty: anAtom 
				offset: offset 
				length: length 
				delete: delete 
				requiredType: requiredType 
				intoActualType: actualType 
				actualFormat: actualFormat 
				numberOfItems: nbItems 
				bytesAfterReturn: bytesAfterReturn 
				data: data
	<primitive: #primitiveNativeCall module: #NativeBoostPlugin error: errorCode>
	
	^self nbCall: #(int XGetWindowProperty(Display display, self, Atom  anAtom, long offset, long length, bool delete, Atom requiredType, Atom * actualType,  int * actualFormat, ulong * nbItems, ulong * bytesAfterReturn, NBExternalAddress * data ))
]]]

Here we see that we use ==NBExternalAddress * data== in a signature.
By default, in NativeBoost, there is no difference whether you specify ==anytype*== or ==anytype**== or ==anytype***== etc in function signature, because NativeBoost treats all pointer types similarly: it just checks that value you passed to the function can be converted to a pointer.
For instance, if we use ==void*== in function signature, we can pass any of following: any variable-byte instance (ByteArray, ByteString etc),
any variable-word instance (WordArray etc) and lastly, an instance of NBExternalAddress.
For variable-sized objects a pointer to the first indexable element will be passed, and for instances of NBExternalAddress which holding a pointer value,
the actual value will be passed.

But if we explicitly specify ==NBExternalAddress * ==, in this case, NativeBoost will accept only an instance of NBExternalAddress as valid argument (no variable-sized arrays),
and instead of passing a value held by NBExternalAddress instance, it will pass a pointer to a location where this value is stored.
As result, after calling the function, it will store an output value in provided NBExternalAddress instance, which we're free to use later.

!!! Dealing with Arrays of C type values

Communicating with C library often requires dealing with arrays of certain data type (ints, floats etc).
There is no direct correspondence between smalltalk Array (array of objects) and arrays in C (array of certain data type values), and NativeBoost provides no implicit conversions between them. While for most basic types, the automatic conversion can be done (integers, floats etc), for any more complex data types, like array of structures it is impossible.
Moreover, conversion between C array and smalltalk Array will require copying data to represent each array element as an object, and obviously require knowledge about the array size beforehand, which also is not always the case. 

In case if we don't need accessing array's elements and just need a space to store array as a whole, we can just use instances of ByteArray big enough
to accommodate C array of requested size (after all, anything held in computer memory is just a bunch of bytes). 
And while this is cheap and simple way to hold external data, there is an apparent downside, when it comes to accessing or enumerating elements of such C array, because ByteArray has no any helpers for that and its elements are bare bytes but not some C type value(s).

	 ==NBExternalArray== to work with arrays whose elements are values of some external (C) type.

The class ==NBExternalArray== should be subclassed and the class side ==initialize== method has to initialize the element type:

% @@note missing explanation why. Especially since after we have NBExternalAddress * data 

For example imagine that we would need an array of windows. We would define it as follows. 

[[[
NBExternalArray subclass: #NBXLibArrayOfWindows
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'NBXLib'

NBXLibArrayOfWindows class>>initialize
	self initElementType: 'NBXLibWindow'
]]]

Run ==NBXLibArrayOfWindows initialize==. 



and the method that uses it:

[[[
NBXLibWindow>>managedWindows
  | numberOfItems dataPtr numberOfItemsBuffer |
  numberOfItemsBuffer := ByteArray new: 4.
  dataPtr := NBExternalAddress new.

  self primGetWindowProperty: (display atomNamed: '_NET_CLIENT_LIST_STACKING')
		offset: 0 
		length: 16rFFFF
		delete: false 
		requiredType: AnyPropertyType
		intoActualType: (ByteArray new: 4)
		actualFormat: (ByteArray new: 4)
		numberOfItems: numberOfItemsBuffer  
		bytesAfterReturn: (ByteArray new: 4) 
		data: dataPtr.

    "Retrieves the actual number of items from the buffer"		
	numberOfItems := numberOfItemsBuffer nbUInt32AtOffset: 0.
	
    "Fetch all the windows and init their display reference"	
  ^ (NBXLibArrayOfWindows onAddress: dataPtr size: numberOfItems) asArray
	       do: [ :aWindow| aWindow display: display ]
]]]

% @@note I do not get why we need (NBXLibArrayOfWindows onAddress: dataPtr size: numberOfItems) nor from where it comes from


You should get all the windows managed by your window manager (including docks and task bars):

[[[
NBXLibDisplay open defaultRootWindow managedWindows inspect
]]]


!! I like to move it, move it

Now the last move. To move and resize windows, Xlib defines the function:

[[[
int XMoveResizeWindow(Display * display, Window w, int x, int y, unsigned int width, unsigned height)
]]]

That should be straight forward to define it on our window class:

[[[
NBXLibWindow>>x: x y: y width: width height: height
	<primitive: #primitiveNativeCall module: #NativeBoostPlugin error: errorCode>
	^self nbCall: #(int XMoveResizeWindow(Display display, self, int x, int y, uint width, uint height))
]]]


Now we can select a window and move it. Here we select the second window.
[[[
aDisplay := NBXLibDisplay open.
aWindow := aDisplay defaultRootWindow managedWindows at: 2.
aWindow x: 10 y: 50 width: 200 height: 500.
aDisplay close.
]]]


!! Reading window attributes

In order to get actual position and size of a Window, we can use the function ==XGetWindowAttributes== defined as follow:

[[[
Status XGetWindowAttributes(Display* display, Window w, XWindowAttributes* window_attributes_return)
]]]

Like the previous example, ==XGetWindowAttributes== has an output argument ==window_attributes_return==. In this case, ==XWindowAttributes== is a structure defined like this:
[[[
typedef struct {
    int x, y;			    /* location of window */
    int width, height;		/* width and height of window */
    int border_width;		/* border width of window */
    int depth;          	/* depth of window */
    Visual *visual;		    /* the associated visual structure */
    Window root;        	/* root of screen containing window */
    int c_class;		    /* InputOutput, InputOnly*/
    int bit_gravity;		/* one of bit gravity values */
    int win_gravity;		/* one of the window gravity values */
    int backing_store;		/* NotUseful, WhenMapped, Always */
    unsigned long backing_planes;/* planes to be preserved if possible */
    unsigned long backing_pixel;/* value to be used when restoring planes */
    Bool save_under;		/* boolean, should bits under be saved? */
    Colormap colormap;		/* color map to be associated with window */
    Bool map_installed;		/* boolean, is color map currently installed*/
    int map_state;		    /* IsUnmapped, IsUnviewable, IsViewable */
    long all_event_masks;	/* set of events all people have interest in*/
    long your_event_mask;	/* my event mask */
    long do_not_propagate_mask; /* set of events that should not propagate */
    Bool override_redirect;	/* boolean value for override-redirect */
    Screen *screen;		    /* back pointer to correct screen */
} XWindowAttributes;
]]]

!!! Defining a Structure

So far we did not define C structures in NativeBoost but we used NBExternalObject (wrapper to an handle to an external opaque objects). 
Now we will tell to NativeBoost that we want to define a structure. Here is the way to proceed. First we create a subclass of ==NBExternalStructure== and we will add on the class side a description of all the structure field using NativeBoost types and alias we define.

@@note what is the advantages over a ExternalObject? Access to information? accessors?

!!!! Defining a subclass.

First we have to create a subclass of ==NBExternalStructure== that will hold this data:
[[[
NBExternalStructure variableByteSubclass: #NBXLibXWindowAttributes
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: 'NBXLibTypes'
	category: 'NBXLib'
]]]

Note that the structure uses the shared pool ==NBXLibTypes== in order to use the type aliases. Before adding the description of all the fields to ==NBXLibXWindowAttributes==, we should define some types that are needed: ==Visual==, ==Screen==, ==Colormap==. We can either use subclasses of ==NBExernalObject==, but as we don't need them we can just add them to the shared pool as ==ulong== (pointers - Xlib uses the name ==XID==).

[[[
NBXLibTypes class>>initialize 

	Display := #NBXLibDisplay.
	Atom := #ulong.
	Window := #NBXLibWindow.
	AnyPropertyType := 0.
	XID := #ulong.
	Colormap := XID.
	Visual := XID.
	Screen := XID.
	Bool := #int.
	Status := #int.
	XWindowAttributes := #NBXLibXWindowAttributes.
]]]

Note we also define ==Bool== and ==Status== as aliases of ==int==, ==XWindowAttributes== as an alias of ==#NBXLibXWindowAttributes==. Execute ==NBXLibTypes initialize==.

!!!! Describing the fields.
Now describe the fields in the ==NBXLibXWindowAttributes== class as follows.

[[[
NBXLibXWindowAttributes class>>fieldsDesc
    ^ #(int x;
        int y;                  " location of window "
        int width;
        int height;             " width and height of window "
        int border_width;       " border width of window "
        int depth;              " depth of window "
        Visual visual;          " the associated visual structure "
        Window root;            " root of screen containing window "
        int c_class;            " InputOutput, InputOnly"
        int bit_gravity;        " one of bit gravity values "
        int win_gravity;        " one of the window gravity values "
        int backing_store;      " NotUseful, WhenMapped, Always "
        ulong backing_planes;   " planes to be preserved if possible "
        ulong backing_pixel;    " value to be used when restoring planes "
        Bool save_under;        " boolean, should bits under be saved? "
        Colormap colormap;      " color map to be associated with window "
        Bool map_installed;     " boolean, is color map currently installed"
        int map_state;          " IsUnmapped, IsUnviewable, IsViewable "
        long all_event_masks;   " set of events all people have interest in"
        long your_event_mask;   " my event mask "
        long do_not_propagate_mask; " set of events that should not propagate "
        Bool override_redirect; " boolean value for override-redirect "
        Screen *screen;         " back pointer to correct screen "
    )
]]]

!!!! Initialize accessors.
NativeBoost provides
and initialize all accessors with ==NBXLibXWindowAttributes initializeAccessors==. 


!!!!Defining the primitive

Now we are ready to define the primitive for ==XGetWindowAttributes== in the class ==NBXLibWindow== as follows:
[[[
NBXLibWindow>>primGetAttributesInto: attributes
	<primitive: #primitiveNativeCall module: #NativeBoostPlugin error: errorCode>
	^self nbCall: #(Status XGetWindowAttributes(Display display, self, XWindowAttributes * attributes) )
]]]

We define also some methods.
[[[
NBXLibWindow>>attributes
	^ NBXLibXWindowAttributes window: self.

NBXLibXWindowAttributes class>>window: aWindow
	| attributes |
	attributes := self new. 
	aWindow primGetAttributesInto: attributes. 	
	^ attributes
]]]

Now we can read the size of our desktop! Try to print this:
[[[
NBXLibDisplay open defaultRootWindow attributes width
]]]


!! Conclusion

Once all the system is setup for Pharo and NativeBoost to load the library - and a lot of things can go wrong with this part - defining your bindings should be straight forward. A major challenge is to define a nice object-oriented API around a C library so you can cut the number of parameters to pass to your primitives.


