! NativeBoost Recipes

There is nothing better than real examples to learn. In this chapter, we will create some bindings to X11 Xlib. This chapter was written by L. Laffont during a visit in the RMOD team and largely revisited by S. Ducasse and I. Stasenko. 


!! Some documentation

First, you may need some documentation:

- The Xlib documentation: http://www.x.org/docs/X11/xlib.pdf
- NativeBoost project on SmalltalkHub: http://www.smalltalkhub.com/#!/~Pharo/NativeBoost
- Language-side Foreign Function Interfaces with NativeBoost: http://hal.archives-ouvertes.fr/docs/00/84/07/81/PDF/paper.pdf


!! Must read before start!

Before doing anything we should check first that we can link with the library that we want to use, here X11. 


First, as the Pharo VM runs in 32-bit, the libraries you want to bind to (and their dependencies) must be compiled for 32-bit. Major Linux distributions provide 32-bit versions of their packages. For example, on ArchLinux 64-bit, when you search for ==libx11== package:

[[[
$ pacman -Ss libx11
extra/libx11 1.6.1-1 [installed: 1.6.0-1]
    X11 client-side library
multilib/lib32-libx11 1.6.1-1
    X11 client-side library (32-bit)
]]]

In order to create the bindings, we need to install the 32-bit package: 

[[[
pacman -S multilib/lib32-libx11
]]]

and the library will be found at ==/usr/lib32/libX11.so==.


Sometimes the library isn't available for 32-bit, so you will have to build it. Often libraries rely on autotools for the compilation and it's just a story of setting ==-m32== flags for ==gcc==. Here's the example for ==YAZ== library:

[[[
$ wget http://ftp.indexdata.dk/pub/yaz/yaz-4.2.63.tar.gz
$ tar -xvzf yaz-4.2.63.tar.gz
$ cd yaz-4.2.63
$ ./configure CFLAGS="-m32" LDFLAGS="-m32"
$ make
$ sudo make install
]]]

We can check that the library is 32-bit with the ==file== command. Here the output mention that the library is 32-bit which is compatible with the current implementation of NativeBoost and Pharo VM \footnote{There are plans to have a 64 bits version of the Pharo VM and as soon as this happens there will be a 64 bit version of NativeBoost.}.

[[[
$ file /usr/local/lib/libyaz.so.4.0.0 
/usr/local/lib/libyaz.so.4.0.0: ELF 32-bit LSB  shared object, Intel 80386, version 1 (SYSV), dynamically linked, BuildID[sha1]=479fbc7e495cb53600f145cf575dc1f176703c20, not stripped
]]]



We also have to be sure that all dependent libraries are found:

[[[
$ ldd /usr/local/lib/libyaz.so.4.0.0
        linux-gate.so.1 (0xf773a000)
        libgnutls.so.28 => /usr/lib32/libgnutls.so.28 (0xf745d000)
        libexslt.so.0 => not found
        libxslt.so.1 => /usr/lib32/libxslt.so.1 (0xf7417000)
]]]

Here ==libexslt.so.0== is not found, so we have to make sure it is present, 32-bit and on the right path. On the system I use, ==libexstl== has been installed on ==/usr/local/lib/== and I should either move them to ==/usr/lib32==, or set the environment variable ==LD_LIBRARY_PATH==.

[[[
$ export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/local/lib
$ ldd libyaz.so
        linux-gate.so.1 (0xf7728000)
        libgnutls.so.28 => /usr/lib32/libgnutls.so.28 (0xf744b000)
        libexslt.so.0 (0xf7434000)
]]]

To add a custom directory globally to ==LD_LIBRARY_PATH==, just add it in ==/etc/ld.so.conf==.

At last, remember that we can write bindings for C libraries easily, other languages such as ==C\+\+== are beyond the scope of this chapter.

!!! To install X11 on Mac
If you are on Mac OSX you can try one of the following way to install X11. Based on our experience, the last one seems more reliable. 
[[[
sudo port install xorg-libX11
sudo port -v install xorg-server
http://xquartz.macosforge.org/landing/
]]]

Once install open a new shell and type ==xeye&== you should get the famous eye application looking at you. 

Oh, do not forget to save your image quite often, a crash can easily occur if we make some mistake on this field!


!! A first NativeBoost binding

Before our program can use a display, we must establish a connection to the X server using ==XOpenDisplay==. 
Taking from the documentation: "==The XOpenDisplay()== function returns a Display structure that serves as the connection to the X server and that contains all the information about that X server. ==XOpenDisplay()== connects your application to the X server through TCP or DECnet communications protocols, or through some local inter-process communication protocol."

The signature in ==Xlib.h== (that you should find at ==/usr/include/X11/Xlib.h== or ==/usr/X11/include/X11== on Mac) is:

[[[
Display *XOpenDisplay(char *display_name);
]]]


First, we can check that Pharo and NativeBoost could load the Xlib library and find the function. In a workspace, inspect the result of:

[[[
self nbGetSymbolAddress: 'XOpenDisplay'  module: '/your/path/to/32-bit/libX11.so'
]]]

That should answer something like ==@ 16rF71D14D0==, the address of the function. If ==nil== is answered, then something is wrong and you should refer to previous section. Else, we can go further!


The function ==XOpenDisplay== takes a pointer on char as parameter (thus a String) and returns a pointer on a ==Display==. 
We could define all the function in a large class representing the library, but we will apply an object-oriented decomposition of the X11 world. Therefore,  we need to define a class that will hold an handle for ==Display==. We can do this by creating a subclass of ==NBExternalObject== as follows:

[[[
NBExternalObject subclass: #NBXLibDisplay
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'NBXLib'
]]]


For each NativeBoost entity we have to define the function ==#nbLibraryNameOrHandle== that answers the path to the module. In order to not define multiple times this function, we can define a ==Trait== to be used by all our ==NBXLib== package classes:

[[[
Trait named: #TNBXLibLibrary
	uses: {}
	category: 'NBXLib'

TNBXLibLibrary class>>nbLibraryNameOrHandle
	^ '/your/path/to/32-bit/libX11.so'

TNBXLibLibrary>>nbLibraryNameOrHandle
	^ self class nbLibraryNameOrHandle
]]]


Then we update the ==NBXLibDisplay== class definition to:

[[[
NBExternalObject subclass: #NBXLibDisplay
	uses: TNBXLibLibrary
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'NBXLib'
]]]


We can now create the binding for the function ==XOpenDisplay==. As it will be used to create a new ==NBXLibDisplay== instance, we should define the primitive on the class side:

[[[
NBXLibDisplay class>>open: displayName
	<primitive: #primitiveNativeCall module: #NativeBoostPlugin error: errorCode>
	^self nbCall: #(NBXLibDisplay XOpenDisplay (char * displayName))
]]]

Note that we specify in the signature that the function returns an ==NBXLibDisplay== (i.e., an instance of the class itself) while the C function mentioned a ==Display== type. NativeBoost is handling that for us. 


Then we can try to open the default X display (number 0):

[[[
NBXLibDisplay  open: ':0'
]]]

that should answer a new instance on ==NBXLibDisplay==. If ==displayName== argument is ==NULL==, XOpenDisplay defaults to the value of the ==DISPLAY== environment variable. As it's often what we want, we can add a new class method named ==open== defined as follows:

[[[
NBXLibDisplay class>>open

	<primitive: #primitiveNativeCall module: #NativeBoostPlugin error: errorCode>
	^self nbCall: #(NBXLibDisplay XOpenDisplay (nil))
]]]

and then we can open the default display with:

[[[
NBXLibDisplay open
]]]

When you inspect the result of the last expression you should obtain Figure

+Inspecing NBXLibDisplay open>file://figures/displayInstance.pdf|width=40|label=displayInstance+


!! About NativeBoostPlugin primitives
Now it is time to explain a bit what we did.

This line:

[[[
<primitive: #primitiveNativeCall module: #NativeBoostPlugin error: errorCode>
]]]

is called a ==pragma==. It indicates that the ==#primitiveNativeCall== of the ==#NativeBoostPlugin== should be called when this method is executed. If it fails, an ==errorCode== is returned and the  code below is executed. The pragma indicates to the system to execute the assembly code that was generated to perform a foreign call. If it fails the code ==nbCall:== is executed. 



[[[
^self nbCall: #(NBXLibDisplay XOpenDisplay (char * displayName))
]]]

The ==nbCall:== will parse the array and produces the adequate machine code to perform a function call. 



!!! Mapping C - Pharo

Now remember that the actual C signature is:

[[[
Display *XOpenDisplay(char *display_name);
]]]

Let us have a look at how NativeBoost maps C to Smalltalk and the inverse. The message ==nbCall:== parses the signature of the function to call as a literal array. NativeBoost automatically does the marshalling between C and Pharo, given a few rules.

First, in C you have these primitive types: ==int==, ==unsigned int==, == void *==  and so on. The NativeBoost parser ==NBFnSpecParser== actually handles single keyword type. So, instead of writing ==unsigned int==, we should use ==uint==. Here are some primitive types and their mapping to Pharo types. 
- uint or int: Integer
- bool: Boolean
- float: Float
- char: Character

See below for a longer list.

!!! About C strings

Usually the C idioms to represent a string datatype is to declare a pointer on a character and that the array containing characters is null terminated - In C there is no such formal type definition of what string is. Now when we want to call functions expecting char ==*== care must be taken. Let us see why.

We should pay attention because  char ==*== data type is not a string. It means that a library could specify such type 
but in reality does not expect a string but simply a pointer. Therefore and read the documentation of the library to make sure
that function argument in the question is expecting a string and not just a pointer to char value.

For null terminated strings, NativeBoost provides special type named ==String==. Using this type, the value is automatically converted between a Smalltalk byteString and a C null-terminated string. 

When you know that your library is really expecting a C null terminated string, it is safer to use ==String== in a NativeBoost type declaration than ==char *== because char ==*== is just managed as a simple pointer to the beginning of string but does not make sure that the string is null-terminated.

So we can change ==NBXLibDisplay class>>open== to use ==String==:

[[[
^self nbCall: #(NBXLibDisplay XOpenDisplay (String displayName))
]]]


!!! Supported Types

Here is the list of types NativeBoost supports by default. We show the C names as well as the NativeBoost equivalent.

!!!! Booleans
- ==bool NBBool==

!!!! Fixed size integer types. Here the byte order is platform dependent. 
- ==int8 NBInt8==
- ==uint8 NBUInt8==
- ==int16 NBInt16==
- ==uint16 NBUInt16==
- ==int32 NBInt32==
- ==uint32 NBUInt32==
- ==int64 NBInt64==
- ==uint64 NBUInt64==

!!!! Aliases to common C compiler types.
Some of them are platform dependent, some is not... because the C standard does not fully specify it

-	==signedByte int8==
-	==unsignedByte int8==
-	==signedShort int16==
-	==unsignedShort uint16==
-	==signedChar int8==
-	==unsignedChar uint8==
-	==schar int8==
-	==uchar uint8==
-	==signedLong int32==
-	==unsignedLong uint32==
-	==sbyte int8==
-	==byte uint8==
-	==short int16==
-	==ushort uint16==
-	==long int32==
-	==ulong uint32==
-	==longlong int64==
-	==ulonglong uint64==
-	==uint uint32==
-	==int int32==

!!!! Unsigned for sizes.
Usually same size as platform's word size. It is unsigned integer types having the same length as a pointer. 
- ==size_t NBSizeT==
		
!!!! Character type. 
-	==Character NBCharacterType==
-	==char NBCharacterType==

Note that Character and char are special. NativeBoost converts between C character and Pharo Character instances. 
If you just want to use unsigned integer value use ==uint8== or ==int8== instead (The 8 indicates that this is one byte). 
		

!!!! Floats fixed-size. 
Here again such type are platform-dependent byte order.

-	==float16 NBFloat16==
-	==float32 NBFloat32==
-	==float64 NBFloat64==
-	==float128 NBFloat128==

!!!! Floats common type names.
NativeBoost provides some aliases to C type names. 				
-	==float float32==
-	==double float64==
-	==shortFloat float16==







!!! Customizing Type Resolution

We can also affect the way NativeBoost resolves types. For example, we would like to keep the type ==Display== used in the C signature instead of writing ==NBXLibDisplay==. So we would like to write simply the following:

[[[
^self nbCall: #(Display XOpenDisplay (String displayName))
]]]


To know which class to use for the ==Display== type, NativeBoost looks up for the type in this order:
- class variable
- shared pool
- class

If we decide to use class variable, we can change the definition of ==NBXLibDisplay== to:

[[[
NBExternalObject subclass: #NBXLibDisplay
	uses: TNBXLibLibrary
	instanceVariableNames: ''
	classVariableNames: 'Display'
	poolDictionaries: ''
	category: 'NBXLib'
]]]

and then initialize the ==Display== class variable. Note that the value is a symbol because the array contains literal values.
Do not forget to evaluate ==NBXLibDisplay initialize== once you define the method:

[[[
NBXLibDisplay class>>initialize

	Display := #NBXLibDisplay
]]]


When we run again ==NBXLibDisplay open==, NativeBoost will map ==Display== return type to ==NBXLibDisplay== class.

As we often need to have these mapping across several classes in our package, it is best to use shared pools. We then define the shared pool ==NBXLibTypes== 
and define a class variable named ==Display== that we initialize correctly. Then all our code is:

[[[
Trait named: #TNBXLibLibrary
	uses: {}
	category: 'NBXLib'

TNBXLibLibrary class>>nbLibraryNameOrHandle
	^ '/your/path/to/32-bit/libX11.so'

TNBXLibLibrary>>nbLibraryNameOrHandle
	^ self class nbLibraryNameOrHandle

SharedPool subclass: #NBXLibTypes
	instanceVariableNames: ''
	classVariableNames: 'Display'
	poolDictionaries: ''
	category: 'NBXLib'

NBXLibTypes class>>initialize 

	Display := #NBXLibDisplay.
	
NBExternalObject subclass: #NBXLibDisplay
	uses: TNBXLibLibrary
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: 'NBXLibTypes'
	category: 'NBXLib'

NBXLibDisplay class>>open
	<primitive: #primitiveNativeCall module: #NativeBoostPlugin error: errorCode>
	^self nbCall: #(Display XOpenDisplay (nil))

NBXLibDisplay class>>open: displayName
	<primitive: #primitiveNativeCall module: #NativeBoostPlugin error: errorCode>
	^self nbCall: #(Display XOpenDisplay (String displayName))

]]]

!!! A word about NBExternalObject

Instances of ==NBExternalObject== represent an external object of one kind, provided by some external library/function. An instance holds a handle, which is used to identify the external object when this instance is passed as an argument, or when it is used as a return type in function signature.

A typical usage of ==NBExternalObject== is to create a subclass, and then use that subclass name directly in function signatures. This is what we did previously.

[[[
NBExternalObject subclass: #NBXLibDisplay

newObj := NBXLibDisplay newObject.

MyExternalObject class>>newObject
	<primitive: #primitiveNativeCall module: #NativeBoostPlugin error: errorCode>
	^self nbCall: #(Display XOpenDisplay (nil))
]]]

Here, we assume that ==XOpenDisplay()== returns some handle (or pointer) to some opaque external structure. Using a NBExternalObject' subclass (e.g., MyExternalObject) as a return type into the function signature, we are telling the code generator to automatically convert the return value into an instance of a given class and initialize its handle to the value returned by the function.

When used as argument type, the value, which is used to pass to the external function is a value held in the ==handle== instance variable.

The main advantage of using ==NBExternalObject== subclass as a type name for arguments is that it provides type safety by checking the incoming argument, that it
is an instance of your class, and nothing else. If not, the primitive will fail without calling the external function.


!! Self magic

To close the connection to a Xlib Display, we should use the C function:

[[[
int XCloseDisplay(Display *);
]]]


Since we are in Pharo, we would like to have an oriented-object API instead of defining all C functions on class side for example. So we would like to close the connection like this: ==myDisplay close==. Let's define an instance level method in the class ==NBXLibDisplay==:

[[[
NBXLibDisplay>>close
	<primitive: #primitiveNativeCall module: #NativeBoostPlugin>
	^self nbCall: #(int XCloseDisplay(Display self))
]]]

See how we use ==self== to refer to the object itself. Even more, with ==self== we can omit the type and just write:

[[[
NBXLibDisplay>>close
	<primitive: #primitiveNativeCall module: #NativeBoostPlugin>
	^self nbCall: #(int XCloseDisplay(self))
]]]

Now we can open and close the display:

[[[
| display |
display := NBXLibDisplay open.
display close.
]]]


!! Let's start the real fun stuff!

The goal of this section is to be able to find our desktop application windows and then to move or resize them. Each window has properties attached, called Atoms. Each Atom type has a unique identifier. When your window manager follows the ==Extended Window Manager Hints (EWMH)== spec (this is the case for Gnome and KDE, see http://standards.freedesktop.org/wm-spec/wm-spec-1.3.html), you can get all windows managed by the window manager using Xlib C function ==XGetWindowProperty== for the Atom ==_NET_CLIENT_LIST_STACKING==.


First we need to find the identifier of the Atom ==_NET_CLIENT_LIST_STACKING== using the Xlib function ==XInternAtom==:
[[[
Atom XInternAtom(Display* display, char* atom_name, Bool only_if_exists)
]]]


As we want to have a nice object-oriented API, we should separate the instance creation method and primitive on a new ==NXLibAtom== class. Let's start with the primitive. ==Atom== is defined in ==X.h== as:

[[[
typedef unsigned long Atom;
]]]

So we should add the definition of the Atom mapping to our shared pool:

[[[
NBXLibTypes class>>initialize 
	Display := #NBXLibDisplay.
	Atom := #ulong
]]]

and we should not forget to run ==NBXLibTypes initialize==.

Now we can define a method ==atomNamed: aString== using the ==XInternAtom== primitive:
 
[[[
NBXLibDisplay>>atomNamed: aString
	<primitive: #primitiveNativeCall module: #NativeBoostPlugin error: errorCode>
	^self nbCall: #(Atom XInternAtom(self, String aString, true))
]]]

Note that we define the method as an instance method since we will invoke it on an existing object representing the display. 
Here we give ==true== to the last argument so the Atom will be created if it does not exist. Note that for booleans we don't need to specify the type. You can check that this is working:

[[[
NBXLibDisplay open atomNamed: '_NET_CLIENT_LIST_STACKING' 
]]]

which answers ==460== on our machine (this changes for each display).


!!! Getting the root window

We need to get the root window of the display before querying any property on it, using the Xlib function:
[[[
Window XDefaultRootWindow(Display *display);
]]]

Since  ==Window== will be an external object we want to attach functions to, so let's define it as:

[[[
NBExternalObject subclass: #NBXLibWindow
	uses: TNBXLibLibrary
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: 'NBXLibTypes'
	category: 'NBXLib'
]]]

and update the shared pool (do not forget to run ==NBXLibTypes initialize==):
[[[
NBXLibTypes class>>initialize 
	Display := #NBXLibDisplay.
	Atom := #ulong.
	Window := #NBXLibWindow.
]]]

We can implement a method defined on the ==NBXLibDisplay== class to get the defaultRootWindow by calling the ==XDefaultRootWindow== function.
Now you should be able to define it by yourself without reading the following definition. We define it as follows:

[[[
NBXLibDisplay>>defaultRootWindow
	<primitive: #primitiveNativeCall module: #NativeBoostPlugin error: errorCode>
	^self nbCall: #(Window XDefaultRootWindow(self))
]]]

This code should answer a ==NBXLibWindow== instance:
[[[
NBXLibDisplay open defaultRootWindow
]]]


As Xlib functions often need to access the display and the window for window manipulations, we should update the code so that a ==NBXLibWindow== instance could reference its display. We add an instance variable ==display== to the NBXLibWindow class and defined accessor methods.

[[[
NBExternalObject subclass: #NBXLibWindow
	uses: TNBXLibLibrary
	instanceVariableNames: 'display'
	classVariableNames: ''
	poolDictionaries: 'NBXLibTypes'
	category: 'NBXLib'

NBXLibWindow>>display: aNBXLibDisplay
	display := aNBXLibDisplay

NBXLibWindow>>display
	^ display

]]]

Then we rename the previous ==defaultRootWindow== to ==primitiveDefaultRootWindow== and move it to the private protocol. Finally we define
a new method ==defautlRootWindow== as follows:


[[[
NBXLibDisplay>>defaultRootWindow
	^ self primDefaultRootWindow display: self ; yourself

NBXLibDisplay>>primDefaultRootWindow
	<primitive: #primitiveNativeCall module: #NativeBoostPlugin error: errorCode>
	^self nbCall: #(Window XDefaultRootWindow(self))


]]]

!!! Getting Properties 

Now the hard part. Xlib defines a generic function to get properties, ==XGetWindowProperty()==. It is a bit verbose and its signature is:
[[[
int XGetWindowProperty (
  Display *display, 
  Window w, 
  Atom property, 
  long long_offset, 
  long long_length, 
  Bool delete, 
  Atom req_type,
  Atom * actual_type_return, 
  int * actual_format_return, 
  unsigned long * nitems_return, 
  unsigned long * bytes_after_return,
  unsigned char ** prop_return);
]]]

- The three first parameters are easy: the display, the root window in our case, and the Atom ==_NET_CLIENT_LIST_STACKING==. 
- For ==long_offset== and ==long_length==, they can be used to do a partial read of the properties. To get easy, we will get all, so ==0== for the offset and ==16rFFFF== for the length. So we don't care about ==bytes_after_return== in our case
- For the ==req_type==, we can use the Xlib constant ==AnyPropertyType== and don't care about ==actual_type_return== and ==actual_format_return== actually

The Atom ==AnyPropertyType== is a special Atom defined to 0. We can add it to the shared pool for later use:

[[[
NBXLibTypes class>>initialize 
	Display := #NBXLibDisplay.
	Atom := #ulong.
	AnyPropertyType := 0.
]]]


!!!! About returned values.

The last five arguments of the function ==XGetWindowProperty== are output parameters. They are used by the library to store
return values at the location that user must provide. This is why they are specified as pointers.

The first four we can use a ByteArray buffer that is big enough to hold the returned data. In our case this is 4 bytes each as we will show just after. The NativeBoost declaration for ==actual_type_return==, ==actual_format_return==, ==nitems_return==, ==bytes_after_return== is simply the following one: 

[[[
Atom * actualType,  int * actualFormat, ulong * nbItems, ulong * bytesAfterReturn
]]]

The last argument requires a bit more attention. 

!!! Dealing with pointer output arguments

The ==prop_return==  is defined as ==unsigned char **==, literally a pointer on a pointer.
What the C idiom want to convey is that the function is expecting a pointer where it will store the pointer to the returned data. From that perspective, the signature ==char **== could have been expressed as ==void **==.

To deal with such idioms, NativeBoost offers the notion of external addresses. Using an instance of the class ==NBExternalAddress==  holds an address.


Now let's define in Pharo the primitive that will retrieve the properties calling the ==XgetWindowProperty()== function.

[[[
NBXLibWindow>>primGetWindowProperty: anAtom 
				offset: offset 
				length: length 
				delete: delete 
				requiredType: requiredType 
				intoActualType: actualType 
				actualFormat: actualFormat 
				numberOfItems: nbItems 
				bytesAfterReturn: bytesAfterReturn 
				data: data
	<primitive: #primitiveNativeCall module: #NativeBoostPlugin error: errorCode>
	
	^self nbCall: #(int XGetWindowProperty(Display display, self, Atom  anAtom, long offset, long length, bool delete, Atom requiredType, Atom * actualType,  int * actualFormat, ulong * nbItems, ulong * bytesAfterReturn, NBExternalAddress * data ))
]]]

Here we see that we use ==NBExternalAddress * data== in a signature. By default, in NativeBoost, there is no difference whether you specify ==anytype*== or ==anytype**== or ==anytype***== etc in function signature, because NativeBoost treats all pointer types similarly: it just checks that value you passed to the function can be converted to a pointer. 

For instance, if we use ==void *== in function signature, we can pass any of following: any variable-byte instance (==ByteArray==, ==ByteString== etc), any variable-word instance (==WordArray== etc) and lastly, an instance of ==NBExternalAddress==.
For variable-sized objects a pointer to the first indexable element will be passed, and for instances of ==NBExternalAddress== which are holding a pointer value,
the actual value will be passed.

But if we explicitly specify ==NBExternalAddress *== as an argument type, in this case, NativeBoost will accept only an instance of ==NBExternalAddress== 
as valid argument (no variable-sized objects), and instead of passing a value held by ==NBExternalAddress== instance, it will pass a pointer to a location where this value is stored.

As result, after calling the function, it will store an output value in provided ==NBExternalAddress== instance, which we're free to use later.


!!!! NBExternalAddress vs. void.
We use ==NBExternalAddress *== and not ==void *== because: using ==void *== we could pass a byte array and we would get back the address stored inside the byte array. And from these four bytes we would have to construct an address. In addition, using NBExternalAddress provides extra safety because NativeBoost will refuse to perform a call when given something else than a NBExternalAddress instance. 




!!! Dealing with Arrays of C type values
So far we defined a method (primitive) to call the C function but we did not define how to perform the actual call.

Communicating with a C library often requires dealing with arrays of certain data type (ints, floats etc).
There is no direct correspondence between Smalltalk arrays (array of objects) and arrays in C (array of certain data type values), and NativeBoost provides no implicit conversions between them because there is no magic.  While for most basic types, the automatic conversion can be done (integers, floats etc), for any more complex data types, like array of structures it is impossible.
Moreover, an automatic conversion between C arrays and instances of ==Array== would require copying/converting data to represent each array element as an object (which is expensive if done systematically). Such automatic conversion requires knowledge about the array size beforehand, which also is not always the case. 

In case, if we don't need accessing array's elements and just need a space to store an array as a whole, we can just use instances of ==ByteArray== big enough
to accommodate C array of requested size (after all, anything held in computer memory is just a bunch of bytes). 
And while this is cheap and a simple way to hold external data, there is a downside, when it comes to accessing or enumerating elements of such C array: Indeed we ==ByteArray== does not provide helpers to access the elements other than bare bytes in an easy way. It means that it can cumbersome to retrieve the elements of C array stored in the ==ByteArray==.

NativeBoost provides a way to operate with arrays of C type using  ==NBExternalArray==. Let us look at a simple example before going back to our X11 tutorial.

!!!! Array of ==int==

Imagine that we want to work with arrays of int (==int [ ]==). We subclass the class ==NBExternalArray== and redefine the class side ==initialize== method to initialize the array element type:

[[[
NBExternalArray subclass: #NBXArrayOfInts
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'NBXLib'

NBXArrayOfInts class>>initialize
	self initElementType: 'int'
]]]

Then before using the class, you should not forget to initialize it by executing ==NBArrayOfInts initialize==.

Now we can create an array of 10 ints as follows:

[[[
(NBXArrayOfInts new: 10) 

  	yields a NBXArrayOfInts(0 0 0 0 0 0 0 0 0 0)
]]]

Since ==NBExternalArray== is a subclass of ==ArrayedCollection==, we can use it as a regular array responding to the normal messages of Array like collections.
The only difference is that the elements has fixed type. If we pass invalid objects in ==at:put:== an error will be raised. The following code snippet shows how to  


[[[
(NBXArrayOfInts new: 10) at: 10 put: -1

(NBXArrayOfInts new: 10) at: 10 put: nil
will raise an error
]]]

!!!! Anonymous classes.
In certain situations, it is tedious to have to define a class for each data types. NativeBoost supports the creation on the fly of anonymous classes using the message ==ofType:==.
Here is the equivalent of the previous one:

[[[
myClass := NBExternalArray ofType: 'int'.
myClass new: 10.
...
]]]


!! Handling a single C value with NBExternalTypeValue

Similar to ==NBExternalArray==, NativeBoost proposes ==NBExternalTypeValue== which instance of which holds a single value of a concrete C type. 
Using sub instances of ==NBExternalTypeValue== is particularly handy when dealing with output parameters of functions (as we will see in the next Section).

For example, to define an output parameter of an int type, first define a subclass of ==NBExternalTypeValue==, then define the class method ==initialize==
as follows:

[[[
NBExternalTypeValue subclass: #NBXIntValue
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'NBXLib'

NBXIntValue class>>initialize
	"self initialize"
	self initValueType: 'int'
]]]

Of course, do not forget to initialize the class (==NBXIntValue initialize==) before using it.

Now we can set and access the value using the messages ==value== and ==value:== for instances of the newly created class. NativeBoost generates those accessors automatically.

[[[
(NBXIntValue new value: 33) value
]]]

Now we can pass instances of this class as a output parameter to function which expects a pointer to an int. Imagine that we have a C function with the signature  ==foo(int * i)== and its Pharo binding ==foo:== method defined as follows:

[[[
foo: aValue
	<primitive: #primitiveNativeCall module: #NativeBoostPlugin error: errorCode>

	^self nbCall: #(void foo(int * aValue))	
]]]

We can simply create an instance of NBXIntValue and pass it to the function. 
[[[
intValue := NBXIntValue new.
self foo: intValue

intValue value "read the value set by a function"
]]]

Note during the call, the function foo() stores an int at the given address (address represented by the instance of ==NBXIntValue==).
Then we can retrieve the value of this stored int as a Pharo ==Integer== sending the message ==value== to ==intValue==.

!!!! Note
Before the introduction of ==NBExternalTypeValue==, you would had to do the following to get the same example working.

[[[
intValueBuffer := ByteArray new: 4.
self foo: intValueBuffer.
value := intValueBuffer nbUInt32AtOffset: 0.
]]]


!!!! Anonymous classes.
Again in certain situations, it is tedious to have to define a class for each data type, especially when there are way too many as in some libraries. NativeBoost supports the creation on the fly of anonymous classes using the message ==ofType:==.
Here is the equivalent of the previous one:

[[[
myClass := NBExternalTypeValue ofType: 'int'.
myClass new value: 10.
...
]]]

Please note that the ==ofType:== expression creates a fresh anonymous subclass each time it is invoked. Since it is expensive, it is recommended to store it in some kind of class variable and reuse the resulting class.


!!! Back to X11
Now we are ready to get write our method to access the existing windows. 
Let us define a new class to handle arrays of windows. We subclass ==NBExternalArray== and we define the class side ==initialize== method as we did previously.

[[[
NBExternalArray subclass: #NBXLibArrayOfWindows
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'NBXLib'

NBXLibArrayOfWindows class>>initialize
	self initElementType: 'NBXLibWindow'
]]]

Do not forget to execute ==NBXLibArrayOfWindows initialize==. 


Now let us define a method ==managedWindows== to access all the currently display windows. We use two instances of ==NBXIntValue==, one to represent the returned number of items and a dummy one for values we do not use. 

[[[
NBXLibWindow>>managedWindows

	| numberOfItems dataPtr dummy |
	numberOfItems := NBXIntValue new. 
	dummy := NBXIntValue new.
	dataPtr := NBExternalAddress new.
	
	self primGetWindowProperty: (display atomNamed: '_NET_CLIENT_LIST_STACKING')
		offset: 0
		length: 16rFFFF
		delete: false
		requiredType: AnyPropertyType 
		intoActualType: dummy
		actualFormat: dummy
		numberOfItems: numberOfItems 
		bytesAfterReturn: dummy 
		data: dataPtr.
		
	"Fetch all the windows"
	^ (NBXLibArrayOfWindows onAddress: dataPtr size: numberOfItems value) 
]]]

Note that we will improve this method because it has some shortcomings. But first have fun and try the following expression. 
You should get all the windows managed by your window manager (including docks and task bars):

[[[
NBXLibDisplay open defaultRootWindow managedWindows inspect
]]]

Now let us explain ==(NBXLibArrayOfWindows onAddress: dataPtr size: numberOfItems value)==. This message returns an array of the given size located on an address in memory. The type of this array elements are C Window opaque type. It means that the  array contains only handles to some windows. Those handles on the Pharo side are represented as NBXLibWindow instances. When we read a particular element like when using at: or do: each time NativeBoost will convert the handle in a fresh ==NBXLibWindow== object. 


To turn an array of handles into an array of ==NBXLibWindow== instances, we send the message ==asArray== to the ==(NBXLibArrayOfWindows onAddress: dataPtr size: numberOfItems value)==. Now we can at the Pharo level connect a window with its display object. This is what we do with the last do statement of the method.

[[[
NBXLibWindow>>managedWindows

	| numberOfItems dataPtr dummy |
	numberOfItems := NBXIntValue new. 
	dummy := NBXIntValue new.
	dataPtr := NBExternalAddress new.
	
	self primGetWindowProperty: (display atomNamed: '_NET_CLIENT_LIST_STACKING')
		offset: 0
		length: 16rFFFF
		delete: false
		requiredType: AnyPropertyType 
		intoActualType: dummy
		actualFormat: dummy
		numberOfItems: numberOfItems 
		bytesAfterReturn: dummy 
		data: dataPtr.
		
	"Fetch all the windows and init their display reference"
	^ (NBXLibArrayOfWindows onAddress: dataPtr size: numberOfItems value) asArray
		do: [ :aWindow| aWindow display: display ]
]]]



!!!! Memory Housekeeping 

The documentation of X11 says that we should free the memory allocated for retrieved data once we no longer need it. Since there is no garbage collector in C, each time we will call this function we will create a memory leak. The documentation says that we should use the ==XFree()== function. Therefore we going to define the ==free:== method as follows.

[[[
NBXLibDisplay>>free: aPointer
	<primitive: #primitiveNativeCall module: #NativeBoostPlugin error: errorCode>

	^self nbCall: #(void XFree (void* aPointer))
]]]

We define ==free:== in NBXLibDisplay because display plays a central role in the window management with X11. But we could have implement it in ==NBXLibWindow==.
Now we change the definition of managedWindows method into its final form.

[[[
NBXLibWindow>>managedWindows

	| numberOfItems dataPtr dummy result |
	numberOfItems := NBXIntValue new. 
	dummy := NBXIntValue new.
	dataPtr := NBExternalAddress new.
	
	self primGetWindowProperty: (display atomNamed: '_NET_CLIENT_LIST_STACKING')
		offset: 0
		length: 16rFFFF
		delete: false
		requiredType: AnyPropertyType 
		intoActualType: dummy
		actualFormat: dummy
		numberOfItems: numberOfItems 
		bytesAfterReturn: dummy 
		data: dataPtr.
		
	"Fetch all the windows and init their display reference"
	result := (NBXLibArrayOfWindows onAddress: dataPtr size: numberOfItems value) asArray 
		do: [ :aWindow| aWindow display: display ].
	display free: dataPtr.
	^ result		
]]]



Here


!! I like to move it, move it

Now the last move. To move and resize windows, Xlib defines the function:

[[[
int XMoveResizeWindow(Display * display, Window w, int x, int y, unsigned int width, unsigned height)
]]]

That should be straight forward to define it on our window class:

[[[
NBXLibWindow>>x: x y: y width: width height: height
	<primitive: #primitiveNativeCall module: #NativeBoostPlugin error: errorCode>
	^self nbCall: #(int XMoveResizeWindow(Display display, self, int x, int y, uint width, uint height))
]]]


Now we can select a window and move it. Here we select the second window.
[[[
aDisplay := NBXLibDisplay open.
aWindow := aDisplay defaultRootWindow managedWindows at: 2.
aWindow x: 10 y: 50 width: 200 height: 500.
aDisplay close.
]]]







!! Reading window attributes

In order to get actual position and size of a Window, we can use the function ==XGetWindowAttributes== defined as follow:

[[[
Status XGetWindowAttributes(Display* display, Window w, XWindowAttributes* window_attributes_return)
]]]

Like the previous example, ==XGetWindowAttributes== has an output argument ==window_attributes_return==. In this case, ==XWindowAttributes== is a structure defined like this:
[[[
typedef struct {
    int x, y;			    /* location of window */
    int width, height;		/* width and height of window */
    int border_width;		/* border width of window */
    int depth;          	/* depth of window */
    Visual *visual;		    /* the associated visual structure */
    Window root;        	/* root of screen containing window */
    int c_class;		    /* InputOutput, InputOnly*/
    int bit_gravity;		/* one of bit gravity values */
    int win_gravity;		/* one of the window gravity values */
    int backing_store;		/* NotUseful, WhenMapped, Always */
    unsigned long backing_planes;/* planes to be preserved if possible */
    unsigned long backing_pixel;/* value to be used when restoring planes */
    Bool save_under;		/* boolean, should bits under be saved? */
    Colormap colormap;		/* color map to be associated with window */
    Bool map_installed;		/* boolean, is color map currently installed*/
    int map_state;		    /* IsUnmapped, IsUnviewable, IsViewable */
    long all_event_masks;	/* set of events all people have interest in*/
    long your_event_mask;	/* my event mask */
    long do_not_propagate_mask; /* set of events that should not propagate */
    Bool override_redirect;	/* boolean value for override-redirect */
    Screen *screen;		    /* back pointer to correct screen */
} XWindowAttributes;
]]]

!!! Defining a Structure

So far we did not define C structures in NativeBoost but we used NBExternalObject (wrapper to an handle to an external opaque objects). 
Now we will tell to NativeBoost that we want to define a structure. Here is the way to proceed. First we create a subclass of ==NBExternalStructure== and we will add on the class side a description of all the structure field using NativeBoost types and alias we define.

@@note what is the advantages over a ExternalObject? Access to information? accessors?

!!!! Defining a subclass.

First we have to create a subclass of ==NBExternalStructure== that will hold this data:
[[[
NBExternalStructure variableByteSubclass: #NBXLibXWindowAttributes
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: 'NBXLibTypes'
	category: 'NBXLib'
]]]

Note that the structure uses the shared pool ==NBXLibTypes== in order to use the type aliases. Before adding the description of all the fields to ==NBXLibXWindowAttributes==, we should define some types that are needed: ==Visual==, ==Screen==, ==Colormap==. We can either use subclasses of ==NBExernalObject==, but as we don't need them we can just add them to the shared pool as ==ulong== (pointers - Xlib uses the name ==XID==).

[[[
NBXLibTypes class>>initialize 

	Display := #NBXLibDisplay.
	Atom := #ulong.
	Window := #NBXLibWindow.
	AnyPropertyType := 0.
	XID := #ulong.
	Colormap := XID.
	Visual := XID.
	Screen := XID.
	Bool := #int.
	Status := #int.
	XWindowAttributes := #NBXLibXWindowAttributes.
]]]

Note we also define ==Bool== and ==Status== as aliases of ==int==, ==XWindowAttributes== as an alias of ==#NBXLibXWindowAttributes==. Execute ==NBXLibTypes initialize==.

!!!! Describing the fields.
Now describe the fields in the ==NBXLibXWindowAttributes== class as follows.

[[[
NBXLibXWindowAttributes class>>fieldsDesc
    ^ #(int x;
        int y;                  " location of window "
        int width;
        int height;             " width and height of window "
        int border_width;       " border width of window "
        int depth;              " depth of window "
        Visual visual;          " the associated visual structure "
        Window root;            " root of screen containing window "
        int c_class;            " InputOutput, InputOnly"
        int bit_gravity;        " one of bit gravity values "
        int win_gravity;        " one of the window gravity values "
        int backing_store;      " NotUseful, WhenMapped, Always "
        ulong backing_planes;   " planes to be preserved if possible "
        ulong backing_pixel;    " value to be used when restoring planes "
        Bool save_under;        " boolean, should bits under be saved? "
        Colormap colormap;      " color map to be associated with window "
        Bool map_installed;     " boolean, is color map currently installed"
        int map_state;          " IsUnmapped, IsUnviewable, IsViewable "
        long all_event_masks;   " set of events all people have interest in"
        long your_event_mask;   " my event mask "
        long do_not_propagate_mask; " set of events that should not propagate "
        Bool override_redirect; " boolean value for override-redirect "
        Screen *screen;         " back pointer to correct screen "
    )
]]]

!!!! Initialize accessors.
NativeBoost provides
and initialize all accessors with ==NBXLibXWindowAttributes initializeAccessors==. 


!!!!Defining the primitive

Now we are ready to define the primitive for ==XGetWindowAttributes== in the class ==NBXLibWindow== as follows:
[[[
NBXLibWindow>>primGetAttributesInto: attributes
	<primitive: #primitiveNativeCall module: #NativeBoostPlugin error: errorCode>
	^self nbCall: #(Status XGetWindowAttributes(Display display, self, XWindowAttributes * attributes) )
]]]

We define also some methods.
[[[
NBXLibWindow>>attributes
	^ NBXLibXWindowAttributes window: self.

NBXLibXWindowAttributes class>>window: aWindow
	| attributes |
	attributes := self new. 
	aWindow primGetAttributesInto: attributes. 	
	^ attributes
]]]

Now we can read the size of our desktop! Try to print this:
[[[
NBXLibDisplay open defaultRootWindow attributes width
]]]


!! Conclusion

Once all the system is setup for Pharo and NativeBoost to load the library - and a lot of things can go wrong with this part - defining your bindings should be straight forward. A major challenge is to define a nice object-oriented API around a C library so you can cut the number of parameters to pass to your primitives.


