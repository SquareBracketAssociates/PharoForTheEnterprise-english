! Seamless: A Reflective Middleware for Pharo (DRAFT) 

Seamless {{{latex:\footnote{\url{http://ss3.gemstone.com/ss/Seamless.html}} }}} 
is a reflective communication middleware for Pharo
that aims to facilitate the prototyping of distributed applications.
It provides developer friendly abstractions and syntactic sugar
for an ''out-of-the-box'' Pharo to Pharo communication experience.
After prototyping your application, Seamless lets you easily 
profile and tweak communication settings such as distribution and
serialization policies for optimizing performance and avoid common
distribution caveats. This Chapter covers version 0.4 of Seamless 
for Pharo 3.0 and will be updated frequently towards version 1.0 (stable release).

''Note: Final version should present a whole prototyping-profiling-tweaking-deployment cycle for one of the examples (plus ui for logging/profiling facilities)''

!!Wait: Reflective What ?

''The first thing we do, let's kill all the lawyers'' \-\- from "Henry VI", Shakespeare

A communication middleware is a networking solution (such as a library or a framework) that aims
to hide some of the complicated networking setup (low-level details of socket management, remote method
invocation, naming etc) from the developer. A reflective communication middleware is the more dynamic 
variant of such a system whose implementation relies on run-time reflection and can thus be itself adapted and configured
at runtime {{{latex:\footnote{For more info on reflective middleware, you can read this overview by Fabio Kon et al: \url{http://www.inf.ufg.br/~fmc/papers/CACM-ReflectiveMiddleware-no-access.pdf}} }}}. 
Seamless is such a reflective middleware for Pharo and as a project can be considered a descendent of Remote Smalltalk 
{{{latex:\footnote{\url{http://www.squeaksource.com/rST.html}} }}} 
which itself was preceded by projects such as OpenCorba {{{latex:
\footnote{\url{http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.79.1783}}
}}} and Distributed Smalltalk {{{latex:
\footnote{\url{http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.22.7323}}
}}}. It was born as an engineering prerequisite for a research prototype on 
remote debugging and has since be used on and off internally by other RMoD projects at INRIA. 

From the point of view of the Pharo developer Seamless aspires to be what RMI and DCOM is for Java and the .NET platforms respectively while leveraging the reflective and dynamic nature of our environment. Seamless may be distinguished from other solutions in that:

- It targets the Pharo environment and strives to integrate with its core facilities (ie available serialization solutions like Fuel, proxy implementations like Ghost etc)
- It provides abstractions, syntactic carbohydrates (sugar) and programming facades to make the prototyping of distributed applications feel ''out-of-the-box''. In a nutshell Seamless is biased towards Rapid Application Prototyping.
- Under the hood it tries to reify every single part of the object distribution process and its policies, so as to allow profiling and fine-tuning for optimizing performance and avoiding common distribution caveats. 

!!Enough Said: Death to Sockets

!!!Installation

To install and start playing around with Seamless evaluate the following code-snippet in your Workspace:

[[[
Gofer it
	url: 'http://ss3.gemstone.com/ss/Seamless';
	package: 'ConfigurationOfSeamless';
	load.

((Smalltalk at: #ConfigurationOfSeamless) project version: '0.4') load.
]]]

Seamless has been ported to Pharo 3.0. To install Pharo on your system follow the online instructions *here>http://pharo.org/download* or *here>http://get.pharo.org/*. Loading Seamless can be also done directly from the command line as follows:

[[[
./pharo-ui Pharo.image config \
          http://ss3.gemstone.com/ss/Seamless \
          ConfigurationOfSeamless \
          --install=0.4
]]]

Then in order to be able to initiate and respond requests from other images evaluate:

[[[
aDeamon := SeamlessDeamon 
		newDefaultWithGlobalAccess 
		startOn: 8080.
]]]

which again can be done directly from the command-line at start-up. 

To sum-up and to facilitate your deployments here is how you can download pharo, load Seamless and start the deamon in your prefered port from scratch:

[[[
wget -O- get.pharo.org | bash;
./pharo-ui Pharo.image config \
          http://ss3.gemstone.com/ss/Seamless \
          ConfigurationOfSeamless \
          --install=0.4 \
          eval "SeamlessDeamon newDefaultWithGlobalAccess startOn: 8080"
]]]

In order to follow the example in this chapter you will be needing two images,
listening to port 8080 (""peer1"" from now on) and 8081 (""peer2"" from now on) respectively.

''Note: eval under pharo-ui exits upon evaluation, fix''

!!!Hallo Transcript !

Once you have your peers set-up you can start sending messages from one to another. The simplest example would be to print the customary \'hallo world\' or a sequence of numbers from peer1 to the transcript of peer2. There are a lot of different ways to do that with Seamless let's see some of them (from peer1):

[[[
"sugar 1"
remoteTranscript := (Transcript from: '127.0.0.1:8081'). 
remoteTranscript open.
remoteTranscript show: 'Hallo World !'.
1 to: 100 do: [:i | 
	remoteTranscript show: i; cr.
].	
]]]

As you can see the only difference with printing locally is on line 2 when we retrieve the remote transcript instead of using the local Transcript of peer1.
We will come back to the trade-offs introduced to your code by this ''transperancy'' between local and remote execution. In the meantime here is some other ways you can retrieve a remote object and start sending messages to it with Seamless:

[[[
"sugar 2"
remoteTranscript := '127.0.0.1:8081' globalAt: #Transcript.
"sugar 3"
remoteEnvironment := '127.0.0.1:8081' asRemoteEnvironment.
remoteTranscript := remoteEnvironment at: #Transcript.
"sugar 4 (alt 1)"
remoteTranscript := (Smalltalk from: '127.0.0.1:8081') globals at: #Transcript.
]]]

This is of course all syntactic sugar with the seamless deamon and protocol working behind the scene to manage your remote references. You can even use these as a base to introduce your own abstractions for fetching remote objects.

At this point the curious reader may have noticed that the above code (especially syntactic sugar 4) implicitely means that a remote peer has full access to the SystemDictionary on the other side and whence the whole system. This is of course intentional and usefull for prototyping but of course rather perilous for deployment.

Remember when we where setting-up our seamless deamon we invoked:

[[[
SeamlessDeamon newDefaultWithGlobalAccess startOn: 8080
]]]

inside the SeamlessDeamon>>newDefaultWithGlobalAccess method (which we will be examining in detail in Section blah) the Smalltalk globals are given as the entry point of communication and the overall distribution policies are set to their most permissive state. 

Restricting which objects can be referenced from your image and how exactly they will behave is a matter of changing this entry point dictionary (to point to a user-defined one rather than the system dictionary) and altering the distribution policy of your deamon. 

''Note: clean up syntactic sugars and loose the SeamlessDeamonManager (just adds complexity)''

!!Between Ping-Pong and the REST

- Before starting log examples from previous section
- The ping-pong examples
- Make a diagram with transparent distribution
on one end REST on the other, explain the
controversy of transparent distribution (ref to IBM paper)
- Explain that in terms of proxyfication/serialization
everything is a subset of transparent distribution (make
analogy with Turing tarpit)
- Explain where OpenCorba, RMI are
- Explain that with Seamless you can be wherever you choose
on the spectrum, give an all serialized rest example

!!Practice Makes Perfect

- All the examples from the presentation

!!Ok, ok: Make me a Remote Tester

- A simple remote testing application with Seamless

!!Ok, ok: Make me a Distributed Game

- Noury's application with Seamless

!!What's Under the Hood

- diagram from PhD ++ Seamless implementation part

!!How It All Works ?

- explain the different cases of distributing objects

!!Open Issues: Where Do We Go From Here ?

- More Doc/Tests
- Refactoring to Patterns (TM)
- Green Threading and UI
- Exception Handling
- Distributed-GC
- Futures
- Monitoring

!!Acks






