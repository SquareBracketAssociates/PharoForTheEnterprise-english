!Mustache Templates for Pharo

Norbert Hartl developed a Mustache package for Pharo.   Mustache is a popular templating engine that is supported in many programming languages *http://mustache.github.io*. This chapter is an introduction to this package and a mini tutorial to get started with Mustache. It is based on the original blog written by Norbert and we extended it to offer a larger covering of the Mustache features.

The syntax of Mustache is small and covers a wide range of use cases. Mustache is simple and versatile. You can use it for many usages. We will show how Mustache is used in Pillar the system used to generate this book. Although it was designed to be a templating engine for HTML pages it is useful in different areas.


!! Getting Started
Mustache is available on smalltalkhub. There is documentation available on how the syntax is to be used. Here are a few examples to show the  messages you have to call in order to make it work.


[[[
MCHttpRepository
	location: 'http://www.smalltalkhub.com/mc/NorbertHartl/Mustache/main'
	user: ''
	password: ''
]]]


@@todo give a oneline to load it.



!! How to use Mustache?

Mustache takes two arguments as input: (1) a template and (2) a context object (which is a list of bindings) and called a hash in Mustache jargon.

A simple Mustache template looks like this (taken literally from the Mustache documentation available at *http://mustache.github.io/mustache.5.html*):

[[[
templateString := 'Hello {{ name }}
You have just won ${{value}}!
{{#in_ca}}
Well, ${{taxed_value}}, after taxes.
{{/in_ca}}'.
]]]

Given a context object with some contents

[[[
context := {
  'name' -> 'Chris'.
  'value' -> 10000.
  'taxed_value' -> (10000 - (10000 * 0.4)).
  'in_ca' -> true } asDictionary
]]]

We execute the template

[[[
(MustacheTemplate on: templateString) value: context
]]]

or

[[[
templateString asMustacheTemplate value: context
]]]

We get the following output: 

[[[
'Hello Chris
You have just won $10000!

Well, $6000.0, after taxes.
'
]]]

As context object we can use Dictionaries and Objects. Dictionaries need to have a key that is used in the template and Objects need a selector with the same name. In this chapter we use Dictionaries because they are easier to illustrate with.


!! Sections

Sections render blocks of text one or more times based on the value of the key in the current context. A section is delimited by a pound hash sign and slash. The pound sign begins it and the slash sign ends it. That is, =={{#number}}== begins a "number" section while {{/number}} ends it.

[[[
templateString := '{{#number}}
  Never shown!
{{/number}}'
]]]

!! Unbound variable or false

When a variable defining a section is set, the section is activated. 
For example, here the =='number'== is bound to true and the =='Shown too'== text is shown.
There are some special cases where the section is not activated: when the variable is missing, when its value is set to false, or an empty list (or string). The following examples illustrated such behavior. 

[[[| templateString context |
templateString := 'Shown.
{{#number}}
  Shown too!
{{/number}}'.
context := { 'number' -> true } asDictionary.
(MustacheTemplate on: templateString) value: context 
 'Shown.

  Shown too!
'
]]]

The same happens when number is bound to another value such as 2.

[[[
| templateString context |
templateString := 'Shown.
{{#number}}
  Shown too!
{{/number}}'.
context := { 'number' -> 2 } asDictionary.
(MustacheTemplate on: templateString) value: context 

 'Shown.

  Shown too!
'
]]]

Now when the variable is bound to false, the section is not activated.

[[[
| templateString context |
templateString := 'Shown.
{{#number}}
  Shown too!
{{/number}}'.
context := { 'number' -> false } asDictionary.
(MustacheTemplate on: templateString) value: context 
 'Shown.
'
]]]

Similarly when the binding is an empty string or an empty collection.
[[[
| templateString context |
templateString := 'Shown.
{{#number}}
  Shown too!
{{/number}}'.
context := { 'number' -> '' } asDictionary.
(MustacheTemplate on: templateString) value: context 
 'Shown.
'
]]]

[[[
| templateString context |
templateString := 'Shown.
{{#number}}
  Shown too!
{{/number}}'.
context := { 'number2' -> '' } asDictionary.
(MustacheTemplate on: templateString) value: context 
 'Shown.
'
]]]


!! Working with lists

We can use collections to make loop constructs in templates. The pounds and and slash characters are delimiting the beginning and the end of a section.


[[[
templateString := 'A list of numbers
{{# list }}
Number: {{ number }}
{{/ list }}'.
]]]

A context object with content

[[[
{
   'label' -> 'fine.
   'list' -> { 
      { 'number' -> 1 } asDictionary.
      { 'number' -> 2 } asDictionary.
    }
} asDictionary
]]]

gives us the output

[[[
'A list of numbers
Number: 1
Number: 2
'
]]]





!! UnescapedToken 





[[[
| template result |
template := MustacheTemplate on: 'This is a test for {{& name }}.'.
result := template value: { 'name' -> '&' } asDictionary .
result = 'This is a test for &.'.
]]]

By default if a template uses a variable that is not defined in a context, it....


!! And Blocks as well

We can use blocks in context objects. They will be evaluated at the time the template is filled out.

[[[
'The alphabet: {{ alphabet }}' asMustacheTemplate 
   value: { 'alphabet' -> [ Character alphabet ] } asDictionary
]]]

prints

[[[
The alphabet: abcdefghijklmnopqrstuvwxyz
]]]


!! Partial templates

Mustache templates have a notion of sub templates that are called partials. Partial templates are useful for reusing and 
composing templates out of simpler ones. With partials we can nested templates this way


[[[
templateString := '<h2>Names</h2>
{{# names }}
   {{> user }}
{{/ names }}'.
]]]

[[[
userTemplateString := '<strong>{{name}}</strong>'.

templateString asMustacheTemplate
   value: {
      'names' {
         { 'name' -> 'Username' } asDictionary } } asDictionary
   partials: {'user' ->  userTemplateString} asDictionary
]]]

prints the output

[[[
<h2>Names</h2>
<strong>Username</strong>
]]]

The dictionary given as partials: argument is supposed to be a dictionary that contains MustacheTemplates itself. A dictionary of strings will do as well because the strings are converted internally.

!! How about json?

Json is really easy to apply to the templates. You should install the NeoJSON package. 
After that it is just as simple as the following example: 

[[[
'I can use {{name}} easily with {{format}}' asMustacheTemplate 
   value: (NeoJSONReader fromString: '{ "name" : "mustache", "format" : "json" }')
]]]
Copy that to pharo workspace and execute to see the result.


!! Example

Here is a schematic way how Mustache is used by pillar.

[[[
pillarString := '! Some text

-item1
-item2'.

pillarDocument := PRDocumentParser parse: pillarString.

htmlString := PRHTMLWriter write: pillarDocument .

'main.template.html' asFileReference mustacheTemplateDuring: [ :template|

'result.html' asFileReference writeStreamDo: [ :outStream |

    outStream nextPutAll: (template value: { 'contents' -> htmlString
} asDictionary)
     ]]
]]]

!! Templates made easy

Mustache can make template dependent tasks very easy from a simple token replacement up to nested structures to create HTML pages. We use them e.g., for generating SOAP templates. The strength of Mustache lays in the syntax and the combination of context objects. So, there is more for you to find what can be done with it. Happy templating !




